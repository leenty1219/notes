## 1.async/await
使用实例
```swift
func fetchUser() async -> String {
    "Tom"   // 示例：假装网络请求
}
Task {
    let name = await fetchUser()
    print(name)
}
// 获取用户信息
func loadUser() async throws -> User {
    let (data, _) = try await URLSession.shared.data(from: url)
    return try JSONDecoder().decode(User.self, from: data)
}

// UIKit 中
Task { @MainActor in
    do {
        let user = try await loadUser()
        self.nameLabel.text = user.name
    } catch {
        self.showError(error)
    }
}

```
错误提升
```swift
func request() async throws -> Data { ... }

Task {
    do { let data = try await request() }
    catch { /* handle */ }
}
```
```swift
// 并发子任务 `async let` 本身就是结构化并发的一部分。
func loadDashboard() async throws -> (User, [Message]) {
    async let user = fetchUserProfile()
    async let messages = fetchMessages()
    return try await (user, messages)
}
适合“动态数量的并发任务”，比如多个 URL：
func fetchAll(urls: [URL]) async throws -> [Data] {
    return try await withThrowingTaskGroup(of: Data.self) { group in
        for url in urls {
            group.addTask { try await fetch(url: url) }
        }
        var results: [Data] = []
        for try await data in group {
            results.append(data)
        }
        return results
    }
}
```


## 2.Combine

[Github的一篇文章](https://heckj.github.io/swiftui-notes/index_zh-CN.html#coreconcepts-publishers)

| 名称           | 含义                           | 示例                                              |     |
| ------------ | ---------------------------- | ----------------------------------------------- | --- |
| Publisher    | 产生事件的源                       | URLSession.dataTaskPublisher、PassthroughSubject |     |
| Subscriber   | 订阅事件的接收者                     | sink、assign                                     |     |
| Subscription | Publisher 和 Subscriber 之间的桥梁 | 自动管理事件生命周期                                      |     |
| Operator     | 数据流操作符                       | map、filter、combineLatest                        |     |
| Subject      | 既是 Publisher 又是 Subscriber   | PassthroughSubject、CurrentValueSubject          |     |
```swift
import Combine

let publisher = [1, 2, 3].publisher
let subscription = publisher
    .sink { value in
        print("接收到：\(value)")
    }
```

```swift
let searchPublisher = searchTextField.textPublisher
    .debounce(for: .milliseconds(300), scheduler: RunLoop.main)
    .removeDuplicates() // 有变化
    .flatMap { keyword in
        api.searchPublisher(keyword)
    }
    .sink { results in
        self.results = results
    }

```
**生命周期管理**
```swift
var cancellables: Set<AnyCancellable> = []

publisher
    .sink { ... }
    .store(in: &cancellables)

```

Operator 是 Combine 的灵魂，它让数据流可以链式处理：

| 操作符              | 功能                  |
| ---------------- | ------------------- |
| map              | 转换事件值               |
| filter           | 过滤事件                |
| debounce         | 防抖，控制频繁事件           |
| throttle         | 节流，控制事件频率           |
| combineLatest    | 合并多个 Publisher      |
| merge            | 合并多个事件流             |
| flatMap          | 将事件映射成另一个 Publisher |
| removeDuplicates | 去除重复值               |
**assign和sink的区别**
```swift
// assign 是自动绑定到属性上
class ViewModel: ObservableObject {
    @Published var name: String = ""
    var cancellables = Set<AnyCancellable>()
}

let vm = ViewModel()
publisher
    .assign(to: \.name, on: vm)
    .store(in: &vm.cancellables)

```
### 2.1 @Publish
```swift
import UIKit
import Combine

class ViewModel {
    @Published var name: String = ""
}

class ViewController: UIViewController {
    var viewModel = ViewModel()
    var cancellables = Set<AnyCancellable>()
    let label = UILabel()

    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 订阅 name 属性变化
        viewModel.$name
            .sink { [weak self] newValue in
                self?.label.text = newValue
            }
            .store(in: &cancellables)
        
        // 修改属性，触发更新
        viewModel.name = "Alice"
    }
}

```
### 2.2 @ObservedObject + objectWillChange.sink
```swift
import UIKit
import Combine
import SwiftUI
//  ObservableObject 标记整个类都可以被观察
class UserViewModel: ObservableObject { 
// 类中被 @Published 标记的属性有变化就会触发 objectWillChange
    @Published  var name: String = "" 
}

class MyViewController: UIViewController {
    @ObservedObject var viewModel = UserViewModel() // 只是语法标记
    var cancellables = Set<AnyCancellable>()
    let label = UILabel()

    override func viewDidLoad() {
        super.viewDidLoad()

        viewModel.objectWillChange
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                self?.label.text = self?.viewModel.name
            }
            .store(in: &cancellables)

        // 修改属性
        viewModel.name = "Bob"
    }
}

```

## 3.Sendable
`Sendable` 表示：

> **一个类型可以安全地在多个线程/任务间传递或共享**

类似 C++ 的 `thread-safe` 或 Rust `Send` trait。

Swift 编译器在并发语境下，会强制类型必须是 Sendable，否则出现编译警告/错
```swift
struct User: Sendable { 
    var id: Int
    var name: String
}
```
Swift 会自动推断大多数轻量值类型是 `Sendable`，  
但引用类型（class）不会默认是安全的，必须声明或处理线程安全
## 4.Actor
如果说 `Sendable` 解决“**跨线程传递数据是否安全**”  
那么 `Actor` 解决“**跨线程访问共享状态是否安全**”
> class   = 普通类
> actor   = 并发安全的类（隔离共享状态）
```swift
actor Counter {
    private var value = 0
    func increment() { value += 1 }
    func getValue() -> Int { value }
}
```
访问 Actor 内部变量时必须使用 `await`：
```swift
let counter = Counter()
await counter.increment()
print(await counter.getValue())
```
✅ Actors 的作用 / 解决的问题

|问题|解决方式|
|---|---|
|多线程竞态（race condition）|actor 自动串行化访问|
|共享数据访问冲突|由编译器保护|
|锁、队列管理复杂|不再需要 DispatchQueue|
|同步问题（既安全又无需锁）|并发友好|

✅ 使用场景

|场景|示例|
|---|---|
|全局缓存|图片缓存、数据缓存|
|网络层状态共享|认证 Token、Session|
|聊天/推送模块|消息未读数并发更新|
|可变模型|购物车数量、后台任务计数|
|日志系统|多模块同时写日志|
## 5.@MainActor
修饰类 / ViewModel，整个类就被锁定在主线程，内部所有方法均自动在主线程执行。
```swift
@MainActor
final class UserViewModel: ObservableObject {
    @Published var name = ""

    func updateName(_ newName: String) {
        self.name = newName
    }
}
```
修饰函数（局部使用）
```swift
@MainActor
func updateUI() {
    // 一定在主线程
    self.label.text = "Updated"
}
```
从后台线程切回主线程
```swift
func fetchData() async {
    let user = await api.loadUser()

    await MainActor.run {
        self.usernameLabel.text = user.name
    }
}
```
如果你在非主线程调用主线程 Actor 的方法，会直接报错/提示：
```swift
@MainActor class ViewModel { ... }  
func backgroundWork() async {
     let vm = ViewModel()     // ❌ 报错：跨 Actor 调用vm.updateName("Jack") 
}
//必须使用 `await`（表明跨 Actor 边界访问）：
await vm.updateName("Jack") // ✅
``` 
✅ UI 层最佳实践

|框架|推荐写法|
|---|---|
|UIKit|ViewModel + @MainActor|
|SwiftUI|ViewModel + @MainActor（ObservableObject天然主线程）|
|与后台服务交互|后台 await -> MainActor.run 切回渲染|

✅ iOS 支持情况

|Feature|iOS 最低|
|---|---|
|`@MainActor`|✅ iOS 15+|
|`MainActor.run`|✅ iOS 15+|

基本所有 async/await 时代的 UI 安全策略都基于 MainActor。

✅ UIKit vs MainActor 的对比（帮助从旧思维迁移）

| 以前 GCD               | 新并发模型               |     |
| -------------------- | ------------------- | --- |
| dispatch_async(main) | await MainActor.run |     |
| 需要记忆在哪个线程            | 编译器强制安全             |     |
| 容易遗漏                 | 无法遗漏                |     |
| 运行时报错                | 编译期阻止               |     |
| 分散                   | 隔离清晰                |     |
具体的几个事例：
```swift
// 1：网络请求后更新 UI（UIKit 常见）
class UserViewController: UIViewController {

    @IBOutlet weak var nameLabel: UILabel!
    let api = UserAPI()

    override func viewDidLoad() {
        super.viewDidLoad()
        Task {
            let user = try await api.fetchUser()
            await MainActor.run {
                self.nameLabel.text = user.name   // UI 安全
            }
        }
    }
}
// SwiftUI 中 ViewModel（天然结合）
@MainActor
final class UserViewModel: ObservableObject {
    @Published var username = ""

    func load() async {
        let user = await API.load()
        username = user.name  // UI 主线程安全
    }
}

struct UserView: View {
    @StateObject private var vm = UserViewModel()

    var body: some View {
        Text(vm.username)
            .task { await vm.load() } // SwiftUI 自动在合适时机调用
    }
}
// 异步列表加载分页，防止线程冲突
@MainActor
final class MessageListViewModel: ObservableObject {
    @Published private(set) var messages: [Message] = []
    private let api = MessageAPI()

    func loadMore() async {
        let new = try await api.fetchNextPage()
        self.messages.append(contentsOf: new) // 主线程追加
    }
}

```
## 6.Task
Task 与 Task.detached（Swift 5.5 / iOS 15+）

 ✅ 先理解一句话：

|API|是否继承当前上下文（actor / priority / task-local）|常见用途|
|---|---|---|
|`Task {}`|✅ 继承|UI/业务逻辑里的异步|
|`Task.detached {}`|❌ 不继承|少数系统级、独立后台任务|

`Task.detached` 就像 “脱离当前线程/Actor 的后台任务”，  
如果误用，很容易产出“跨线程访问UI” 或 “绕过MainActor保护”。
```swift
Task {
    let data = try await api.fetchData()
    await MainActor.run {
        self.label.text = data.title
    }
}
```
- 继承调用处的 Actor（如果在 MainActor 内，则它也是 MainActor）
- 自动拥有 `@MainActor` 保护
- 是 UI 业务代码首选

**Task.detached** 是什么？
```swift
Task.detached {
    // 这里是完全新的上下文，不继承 MainActor
    // 本质：后台隔离任务
}
```

|属性|Task|Task.detached|
|---|---|---|
|是否继承 MainActor|✅ 是|❌ 否|
|是否继承上下文|✅ 是|❌ 否|
|是否用于后台独立计算|❌ 少|✅ 常用|
|UI 更新安全吗|✅ 安全（隐式）|❌ 不安全，需要手动切回|
什么时候应该考虑使用 Task.detached？

|场景|原因|
|---|---|
|大量计算（不关心 UI）|不抢占主线程|
|后台数据库操作|不与 UI Actor 绑定|
|独立的后台任务管理器|不与父任务生命周期绑定|
|低级服务（网络缓存，加密，图片处理）|不继承主线程避免污染调度|
```swift
Task.detached {
    let result = heavyImageProcess()
    await MainActor.run {
        self.imageView.image = result
    }
}
```
总结：**UI/业务代码用 Task，性能/后台代码才用 Task.detached**

**Task优先级以及取消**
```swift
class SearchViewModel: ObservableObject {
    private var currentTask: Task<Void, Never>?

    func search(keyword: String) {
        currentTask?.cancel()
        currentTask = Task {
            try Task.checkCancellation()
            let result = try await api.search(keyword)
            try Task.checkCancellation()
            await MainActor.run {
                self.suggestions = result
            }
        }
    }
}

class MessageViewModel: ObservableObject {
    private var loadTask: Task<Void, Never>?

    func loadMore() {
        loadTask?.cancel()
        loadTask = Task(priority: .utility) {
            let page = try await api.fetchNextPage()
            await MainActor.run {
                self.messages.append(contentsOf: page)
            }
        }
    }
}
```
## 7.Continuation（把回调接口改造为 async/await）
**withCheckedContinuation** 无错误
**withCheckedThrowingContinuation**（带错误）
```swift
func loadImage(url: URL) async -> UIImage? {
    await withCheckedContinuation { continuation in
        oldLoadImage(url: url) { image in
            continuation.resume(returning: image)
        }
    }
}
func fetchUser(id: Int) async throws -> User {
    try await withCheckedThrowingContinuation { continuation in
        oldFetchUser(id: id) { result in //旧方式，以promise类似
            switch result {
            case .success(let user):
                continuation.resume(returning: user)
            case .failure(let error):
                continuation.resume(throwing: error)
            }
        }
    }
}
```
## 8.Swift Macro
- 普通函数：在运行时执行
- Macro：在编译期生成 Swift 代码
- 生成的代码可以像普通 Swift 代码一样使用
Swift 5.9+ 提供三种主要 Macro 类型：

|类型|功能|示例场景|
|---|---|---|
|**Freestanding Expression Macro**|用在表达式位置，生成表达式|`#assertEven(4)` → 自动生成表达式|
|**Freestanding Declaration Macro**|生成声明（函数/变量/类型）|自动生成 Equatable/Hashable 实现|
|**Attached Declaration Macro**|附加到声明上，扩展已有类型|`@AutoCodable` → 自动生成 Codable 实现|
```swift
import SwiftSyntaxMacros
import SwiftDiagnostics

public struct HelloMacro: ExpressionMacro {
    public static func expansion(of node: some SwiftSyntaxMacroExpansionSyntax, in context: some MacroExpansionContext) throws -> ExprSyntax {
        return "Hello, Macro!".asExprSyntax
    }
}
```
