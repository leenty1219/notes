# 1.基础知识

## 1.1 iOS修饰属性关键字

`atomic`、`nonatomic`、`weak`、`strong`、`assign 、readonly`、`readwrite`、`class`、`getter`、`retain` 、`copy` 、`unsafe_unretained`

## 1.2 面相对象

## 1.3 实现Copy协议

如果需要自定义的类实现`copy`方法需要遵守`NSCopying`和`NSMutableCopying`协议，并手动实现对应的协议方法

```objectivec
- (nonnull id)copyWithZone:(nullable NSZone *)zone { 
}
- (nonnull id)mutableCopyWithZone:(nullable NSZone *)zone { 
}
```

## 1.4 Block如何捕获外部变量

`Block` 是一个特殊的`结构体`；

它是**`Objective-C` 对象**，内部存储了一段**`函数指针`**和**`捕获的变量`**；

捕获变量时，**编译器**会将相关变量的值或地址写入 Block 的结构体内部

> 编译器会根据内部需要捕获的变量来生成对应带捕获变量的结构体

eg.

```cpp
int global_age = 30;

int main(int argc, const char * argv[]) {
  int age = 10;
  static int static_age = 20;
  Person *per = [[Person alloc] init];
  __weak typeof(per) weakPer = per;

  void (^block)(void) = ^{
    printf("block: %p, %p, %d, %d, %d\\n", per, weakPer, age, static_age, global_age);
  };
  block();
  return 0;
}

// --------------------  转换后的代码  ------------------------
// block 的结构体。
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  Person *__strong per;
  Person *__weak weakPer;
  int age;
  int *static_age;
};

// block 的执行体。
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    Person *__strong per = __cself->per;
    Person *__weak weakPer = __cself->weakPer;
    int age = __cself->age;
    int *static_age = __cself->static_age;
    
    printf("block: %p, %p, %d, %d, %d\\n", per, weakPer, age, *static_age, global_age);
}

// 当 block 被拷贝到堆上时，会调用这个函数对捕获的对象变量进行内存管理。
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {
    _block_object_assign((void*)&dst->per, (void*)src->per, 3);
}

// 当 block 释放时，会调用这个函数对捕获的对象变量进行释放。
static void __main_block_dispose_0(struct __main_block_impl_0*src) {
    _block_object_dispose((void*)src->per, 3);
}

// block 的描述信息。
static struct __main_block_desc_0 {
  size_t reserved;
  size_t block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main(int argc, const char * argv[]) {
  // 此处省略了 age、per、weakPer、static_age 的初始化代码。

  void (*block)(void) = &__main_block_impl_0(__main_block_func_0, 
                                            &__main_block_desc_0_DATA, 
                                            per, weakPer, age, 
                                            &static_age, 570425344);
  block->FuncPtr(block);
  return 0;
}
```

## 1.5 @**synthesize & @dynamic**

`synthesize`意思是合成，有两个功能：

- 给属性生成setter / getter 方法
- 给属性起个别名

```objectivec
@synthesize hobby = _newHobby; // hobby 是我们定义的名称，_newHobby是生成的新名称
```

手动添加了setter / getter 方法后，系统就不会自动创建成员变量了，这个时候如果需要使用成员变量则要手动添加`@synthesize`来生成成员变量。

`@dynamic` 不会帮我们生成`get`、`set`方法，同时也**不会**生成`下划线`方法

## 1.6 onion 使用

```objc
union BLEData {
    int8_t data[4];
    int32_t value;
};
//---------------
BLEData ble;
ble.value = CFSwapInt32HostToBig(0x1B9901);
NSData * data1 = [NSData dataWithBytes:ble.data length:4];
NSLog(@"BELData data = %@",data1);
```

## 1.7 结构体

```objc
Byte value[4]={0};
value[0]=0;
value[1]=0x1B;
value[2]=0x99;
value[3]=0x01;
NSData * data = [NSData dataWithBytes:&value length:sizeof(value)];

/******/

Byte value[4] = {0x01, 0x99, 0x1B, 0x00};  // 按小端顺序，注意大小端顺序问题
NSData * data = [NSData dataWithBytes:&value length:sizeof(value)];
```

# 2.Swift特性

## 2.1 语法层面

1.类型安全

2.代码简洁

3.有`高阶函数`、`重载`、`面向协议编程`、`泛型`等特性

4.Swift 速度更快，运算性能更高，(Apple 专门对编译器进行了优化)

## 2.2 Static和Class的区别

1.`static` 修饰都可以表示类方法类与属性（包括存储属性和计算属性）

2.`class` 是专门用在 `calss 类型`中修饰类方法和类的计算属性（**不能修饰存储属性和计算属性**）。

3.`class` 无法修饰存储属性，而 static 可以

4.使用 static 修饰的类方法和类属性无法在子类中重载

## 2.3访问控制

Swift中提供了5个访问属性： `open` 允许在任意模块中访问、继承、重写，**open 只能用在 类 、 类成员上** `public` 允许在任意模块中访问，**修饰类时不允许其他模块进行继承、重写**

`internal` （默认）只允许在定义实体的模块中访问，不允许在其他模块中访问

`fileprivate` 只允许在定义实体的源文件中访问

`private` 只允许在定义实体的封闭声明中(作用域)访问

## 2.3值类型的优势

1.值类型和引用类型相比,最大优势可以**高效的使用内存**

2.值类型在栈上操作,引用类型在堆上操作。减少了堆上内存分配和回收次数

3.栈上操作仅仅是单个指针的移动

4.堆上操作牵涉到**合并,位移,重链接**

## 2.5 Swift和OC协议异同点

`相同点：`两者都是用作代理

`不同点`：

- Swift中的 protocol 还可以对接口进行抽象,可以实现面向协议,从而大大提高编程效率
- Swift中的 protocol 可以用于`值类型`,`结构体`,`枚举`

## 2.4 Swift值观察器

`willset`

`didset`

## 2.5 Swift指针

`MemoryLayout` 有三个属性分别是`size`、`stride`、`alignment`

- size ：表示占用的内存大小
- stride：表示内存对齐后的大小（实际分配的大小）
- alignment：对齐大小（不够倍数，补齐）

Swift可操作指针一共有8个，且都是内存不安全的

|指针名|Strideable|Write Access|Collect|Typed|
|---|---|---|---|---|
|`UnsafePointer<T>`|Y|N|N|Y|
|`UnsafeMutablePointer<T>`|Y|Y|N|Y|
|`UnsafeRawPointer`|Y|N|N|N|
|`UnsafeMutableRawPointer`|Y|Y|N|N|
|`UnsafeBufferPointer<T>`|N|N|Y|Y|
|`UnsafeMutableBufferPointer<T>`|N|Y|Y|Y|
|`UnsafeRawBufferPointer`|N|N|Y|N|
|`UnsafeMutableRawBufferPointer`|N|Y|Y|N|

- `Pointer Name`：不可变/可变，原生（raw）/有类型、是否是缓冲类型（buffer）
- `unsafe`：不安全的
- `Strideable`：指针可使用 advanced 函数移动
- `Write Access`：可写入
- `Collection`：像一个容器，可添加数据
- `Typed`：是否需要指定类型（泛型）

> Raw：包含Row的是原生指针，不包含的是泛型指针

```swift
/// 带Raw的可以指向任意地址，所以申请的时候需要指定申请空间大小
let size = MemoryLayout<Int>.size
let alignment = MemoryLayout<Int>.alignment
let pointer = UnsafeMutableRawPointer.allocate(byteCount: 8, alignment: alignment)
pointer.storeBytes(of: 32, as: Int.self)
let value = pointer.load(as: Int.self)
print(value) // 打印 32

/*
首先使用 allocate 方法创建了一个指向未初始化内存的 UnsafeMutableRawPointer 对象。
byteCount 参数指定了要分配的字节数，这里是 Int 的 8 字节，
alignment 参数指定了 Int 的对齐方式。

pointer.storeBytes 这一行代码将值 32 存储到 pointer 指向的内存中。
storeBytes 方法用于将值存储到指定内存地址中，as 参数指定了要存储的值的类型，这里传 Int。
pointer.load 这一行代码从 pointer 指向的内存中加载一个 Int 类型的值，并将其赋值给 value 变量。
load 方法用于从指定内存地址中加载值，as 参数指定了要加载的值的类型，因此最终打印结果是 32。
*/
```

# 3.Runtime

## **3.1 Runtime 简介**

> Objective-C 语言是一门动态语言。它把一些决策从编译阶段、链接阶段推迟到运行时阶段，实现该机制的基础就是 `runtime`（又叫作运行时）。

- `静态语言`：在编译阶段就已确定所有变量的数据类型，同时也确定要调用的函数，以及函数的实现。常见的静态语言，如：C/C++、Java、C# 等。
- `动态语言`：程序在运行时可以改变其结构。也就是说在运行时检查变量数据类型，同时在运行时才会根据函数名查找要调用的具体函数。如 Objective-C。

### **3.1.1 Runtime 是什么**

`Runtime` 提供的接口基本都是 `C` 语言，源码由 `C\\C++\\汇编语言`编写。Runtime API 为 Objective-C 语言的动态属性提供支持，充当一种用于 Objective-C 语言的操作系统，使得该语言正常运转工作。

### **3.1.2 Runtime 的版本和平台**

在不同平台上有不同版本的 Objective-C Runtime。[runtime开源代码](https://opensource.apple.com/tarballs/objc4/)

### **3.1.3 Versions**

Objective-C 运行时有两个版本 `modern（现代版本）` 和 `legacy（旧版本）`。现代版本是在 Objective-C 2.0 中引入的，其中包括许多新功能。旧版运行时的编程接口在 Objective-C 1.0 运行时参考中有所描述；[Objective-C Runtime Reference](https://developer.apple.com/documentation/objectivec/objective_c_runtime) 中描述了现代版本的运行时的编程接口。

最值得注意的新功能是现代运行时中的实例变量是 `non-fragile` (非脆弱的)：

- **在旧版运行时中，如果更改类中实例变量的布局，则必须重新编译从其继承的类。**
- **在现代运行时中，如果更改类中实例变量的布局，则不必重新编译从其继承的类。**

另外，现代的运行时支持声明的属性的实例变量综合（请参见 [The Objective-C Programming Language](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163) 和 [Declared Properties](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17)）

### **3.1.4 Platforms**

_**OS X v10.5**_ 及更高版本上的 iPhone 应用程序和 64 位程序使用现代版本的 `Runtime`。

其他程序（OS X 桌面上的32位程序）使用运行时的旧版本。

## **3.2 深入 Runtime 的前期铺垫**

学习 `Runtime`，必绕不开 `Runtime` 底层常用的数据结构，比如 `isa` 指针，`Class` 的结构等。

### **3.2.1 isa 详解**

- 在`arm64`架构之前，`isa`就是一个普通的指针，存储着`Class`、`Meta-Class`对象的内存地址；
- 从`arm64`架构开始，对`isa`进行了优化，变成了一个联合体（`union`）结构，还使用位域来存储更多的信息。由从runtime开源代码中整理源码得：

```c
struct objc_object {
private:
    isa_t isa;// 8 bytes
public:
...
}

union isa_t {
    Class cls;
    uintptr_t bits;
#if defined(ISA_BITFIELD)
    struct {
        ISA_BITFIELD;// defined in isa.h
    };
#endif
};

```

下图是 `ISA_BITFIELD` 的定义：

![image.png](attachment:34ceca5e-9432-4280-b5e4-13d1ec730d5c:image.png)

上面联合体 `isa_t` 涉及到一个位域的概念，可以参考[《C语言位域（位段）详解》](http://c.biancheng.net/view/2037.html)。

> 因为部分数据在存储时候并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。

`isa_t` 使用了位域，这里 `ISA_BITFIELD` 位域成员通过跟 `bits` 相与来取对应的值。

在 `ISA_BITFIELD` 中定义的参数的含义：

![image.png](attachment:f595b5b7-04b9-468b-b389-1fbb3a9f5cf7:image.png)

### **3.2.2 `objc_class` 结构**

Objective-C 类是由 `Class` 类型来表示的，它实际上是一个指向 `objc_class` 结构体的指针。

```c
typedef struct objc_class *Class;
```

类对象结构体 `objc_class` 继承实例对象结构体 `objc_object`。

```c
// 类对象结构体 objc_class 继承 实例对象结构体 objc_objectstruct objc_class : objc_object {
// Class ISA;
    Class superclass;
    cache_t cache;// formerly cache pointer and vtableclass_data_bits_t bits;// 用户获取具体类信息
    ...
}
```

### **3.2.3 `class_rw_t` 结构**

通过 `objc_class` 的 `bits` & `FAST_DATA_MASK` 获取到 `class_rw_t` 结构体信息：

```c
struct class_rw_t {
    uint32_t flags;
    uint16_t witness;
#if SUPPORT_INDEXED_ISA
    uint16_t index;
#endif// explicit_atomic 是为了安全操作
    explicit_atomic<uintptr_t> ro_or_rw_ext;
    Class firstSubclass;
    Class nextSiblingClass;
    ...
}

struct class_rw_ext_t {// class_rw_t 扩展const class_ro_t *ro;
    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;
    char *demangledName;
    uint32_t version;
};
```

`class_rw_t` 里面的 `methods`、`properties`、`protocols` 是二维数组，是可读可写的，包含了类的初始内容、分类的内容，我们拿 `methods` 举例子：

![image.png](attachment:4aa441af-691f-4725-b06a-73373f0c656b:image.png)

### **3.2.4 `class_ro_t` 结构[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#23-class_ro_t-%E7%BB%93%E6%9E%84)**

上述的 `class_rw_ext_t` 中 `class_ro_t` 结构体信息：

```c
struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endifconst uint8_t * ivarLayout;
    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;
    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
    ...
}
```

`class_ro_t` 里面的 `baseMethodList`、`baseProtocols`、`ivars`、`baseProperties` 是一维数组，是只读的，包含了类的初始内容，我们拿 `baseMethodList` 举例子：

![](https://img2020.cnblogs.com/blog/2164037/202104/2164037-20210414224635081-1132358206.png)

### **3.2.5 `method_t` 结构[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#24-method_t-%E7%BB%93%E6%9E%84)**

`method_t` 是对方法、函数的封装，他的结构是：

```c
using MethodListIMP = IMP;
struct method_t {
    SEL name;// 方法、函数名const char *types;// 编码 （返回值类型、参数类型）
    MethodListIMP imp;// 指向方法、函数的指针（函数地址）
    ...
};
```

### **3.2.6 `imp` 属性**

`method_t` 结构体中的 `imp` 代表函数的具体实现，底层源码中的定义：

```c
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void/* id, SEL, ... */ );
#elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);
#endif
```

### **3.2.7 `SEL` 属性**

- `SEL` 代表方法、函数名，一般叫做选择器，底层结构跟 `char *` 类似，获取方法：
    - 可以通过 `@selector()` 和 `sel_registerName()` 获得；
    - 可以通过 `sel_getName()` 和 `NSStringFromSelector()` 转成字符串；
    - 不同类中相同名字的方法，所对应的方法选择器是相同的。

底层源码中的定义：

```c
typedef struct objc_selector *SEL;
```

### **3.2.8 `types` 属性**

- `types` 包含了函数返回值、参数编码的字符串。
    
    ![](https://img2020.cnblogs.com/blog/2164037/202104/2164037-20210414224658533-1292411914.png)
    

我们借助 MJ 封装的 `MJClassInfo.h` 文件获取底层数据结构 `baseMethodList` 的第一个参数：

![image.png](attachment:cf6abbbf-9106-449a-b041-1d63c3782778:image.png)

我们得到 `types` 的值：

```c
// 方法
- (int)test:(int)age height:(float)height;
// types： “i24@0:8i16f20”
```

这个 `types` 值表示什么呢？iOS 中提供了一个叫做 `@encode` 的指令，可以将具体的类型表示成字符串编码。

我主要说一下前面 的 `i` 表示返回值类型 `int`，`24` 表示这个方法返回值类型和参数类型，总共需要的字节数。

还有就是方法默认是带有 `id` 类型和 `SEL` 类型，`types` 中的 '@' 和 ':'，隐式的。

其他的可以通过下面查询：

|Code|Meaning|Code|Meaning|
|---|---|---|---|
|c|A char|*|A character string (`char *`)|
|i|An int|@|An object (whether statically typed or typed id)|
|s|A short|#|A class object (Class)|
|l|A longl is treated as a 32-bit quantity on 64-bit programs.|:|A method selector (SEL)|
|q|A long long|[array type]|An array|
|C|An unsigned char||A structure|
|I|An unsigned int|(name=type...)|A union|
|S|An unsigned short|bnum|A bit field of num bits|
|L|An unsigned long|^type|A pointer to type|
|Q|An unsigned long long|?|An unknown type (among other things, this code is used for function pointer)|
|f|A float|d|A double|
|B|A C++ bool or a C99 `_Bool`|v|A void|

### **3.2.9 方法缓存[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#25-%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98)**

Class 内部结构中有个方法缓存（`cache_t`），调用了方法之后会缓存在里面，他用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。下面是整理出来的重要部分代码：

![](https://img2020.cnblogs.com/blog/2164037/202104/2164037-20210414224717032-1016049574.png)

这里的散列表的原理就是，通过 `@selector(methodName)` & `_mask` 获得一个索引值，通过这个索引就能很快在 `buckets` 中拿到对应的 `bucket_t(key, _imp)`；当然存放也是一样的方式。

- 存放：如果生成的索引在 `buckets` 下已经存在 data 。那么他会把 index - 1，减到零了还没有空闲位置，它会从数组最大值开始继续往前找位置，直到有位置；
- 获取：在拿到 `bucket_t` 后，会比较一下 `key` 与 `@selector(methodName)` 是否对应，如果不对应，那就回按照存放的那样方式一个一个找。如果存满了，`buckets` 就会走扩容。

这就是空间换时间。

## **3.3 深入探究 Runtime**

OC 中方法调用通过 Runtime 实现，Runtime 进行方法调用最重要的底层本质就是Runtime 消息机制，同时我们也会讨论 Runtime 的常见应用。

### **3.3.1 Runtime 消息机制[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#1-runtime-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6)**

OC 中的方法调用，编译时候都会转换为 `objc_msgSend` 函数的调用：

```objectivec
[obj methodName] => objc_msgSend(obj, @selector(methodName))
// 消息接收者：obj// 消息名称： @selector(methodName)
```

`objc_msgSend` 的执行流程可以分为 3 大阶段

- **消息发送**
- 找不到消息发送方法，就会进入**动态方法解析**，允许开发者动态创建新方法；
- 如果动态方法解析没有做任何操作，这时候就开始进入**消息转发**。

如果这三个阶段都没有搞定，也就是说 `objc_msgSend` 没找到合适的方法调用，就会报一个很经典的错误：

```css
unrecognized selector sent to instance

```

关于消息机制的这块的源码（第一节提供的源码地址下载），主要是在 `objc-msg-arm64.s` 、`objc-runtime-new.mm` 以及 Core Foundation 的 **forwarding** 中（这一块不开源）。

### **3.3.2 消息发送[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#11-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81)**

下面是消息发送的流程：

![](https://img2020.cnblogs.com/blog/2164037/202104/2164037-20210414224744579-1938068134.png)

源码自行下载阅读，稍稍费劲点。

### **3.3.3 动态方法解析[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#12-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90)**

下面是动态方法解析的流程：

![](https://img2020.cnblogs.com/blog/2164037/202104/2164037-20210414224750339-598152410.png)

我们通过代码去分析一波：

`Person.h`

```objectivec
@interface Person : NSObject
- (void)test;
@end
```

`Person.m`

```objectivec
#import <objc/runtime.h>
@implementation Person

- (void)other {
    NSLog(@"%s", __func__);
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(test)) {
// 获取 other 方法信息
        Method method = class_getInstanceMethod(self, @selector(other));
// 动态添加 test 方法的实现
        class_addMethod(self, sel,
            method_getImplementation(method),
            method_getTypeEncoding(method));
// 返回 YES 代表有动态添加方法return YES;
    }
    return [super resolveInstanceMethod:sel];
}

@end

```

在 `main` 文件运行：

```csharp
Person *person = [[Person alloc] init];
[person test];
```

我们通过打印能看到：

```less
2021-04-14 11:36:52.022282+0800 StudyOC[5105:7228146] -[Person other]
```

我们通过 `resolveInstanceMethod` 去动态配置 `test`，当我们运行 `test` 实际上调用的是 `other` 方法。上面分析了实例方法，类方法操作也是一样的，只是使用的方法不一样。这里需要注意的是类方法的动态解析中 `class_addMethod` 第一个参数传的不是 `self` 而是 `object_getClass(self)`。

动态解析过后，会重新走“消息发送”的流程，从 receiverClass 的 cache 中查找方法这一步开始执行。

### **3.3.4 消息转发[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#13-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91)**

下面是动态方法解析的流程：

![](https://img2020.cnblogs.com/blog/2164037/202104/2164037-20210414224802603-604263730.png)

还是拿上述的 `Person` 类举例子：

```objectivec
// YYWeakProxy.m 的使用示例
- (id)forwardingTargetForSelector:(SEL)selector {
    return _target;
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    void *null = NULL;
    [invocation setReturnValue:&null];
}
```

这时候在 `main` 调用 `Person` 的对象方法 `test`，实际执行的是 `Student` 的对象方法 `test`；

如果 `forwardingTargetForSelector` 返回值是空的；那么就会继续走 `methodSignatureForSelector` 方法，下面：

```objectivec
- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(test)) {
        return nil;
    }
    return [super forwardingTargetForSelector:aSelector];
}
// 方法签名：返回值类型、参数类型
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(test)) {
        return [NSMethodSignature signatureWithObjCTypes:"v16@0:8"];
    }
    return [super methodSignatureForSelector:aSelector];
}

// NSInvocation 封装了一个方法调用，包括：方法调用者、方法名、方法参数// 方法调用者：anInvocation.target// 方法名：anInvocation.selector// 方法参数：[anInvocation getArgument:NULL atIndex:0];
- (void)forwardInvocation:(NSInvocation *)anInvocation {
// 等同与 [anInvocation invokeWithTarget:[[Student alloc] init]];
    anInvocation.target = [[Student alloc] init];
    [anInvocation invoke];

}
```

开发者可以在 `forwardInvocation:` 方法中自定义任何逻辑，以上方法都有对象方法、类方法。

### **3.3.5 `super`[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#14-super)**

`super` 调用，底层会转换为 `objc_msgSendSuper2` 函数的调用，接收2个参数：`struct objc_super2`、`SEL`。他直接调用获取父类方法。

这里消息接收者还是子类，只是说从父类开始查找方法实现。

```c
struct objc_super2 {
  id receiver;// receiver 是消息接收者
  Class current_class;// current_class 是 receiver 的 Class 对象
}
```

### **3.3.6 Runtime 常见应用场景[#](https://www.cnblogs.com/qiuzhaohai/p/14660332.html#21-runtime-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)**

Runtime 是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景：

- 查看私有成员变量
- 字典转模型
- 替换方法实现
- 给分类增加属性

### **3.3.7 查看私有成员变量**

~~如设置 `UITextField` 占位文字的颜色~~，_**但是 iOS 13 系统禁止 KVC 对系统 API 私有属性的设置，同理其他私有属性的读写建议也进行修改。**_

```objectivec
// 已经禁用
[_passwordTextField setValue:RGBCOLOR(176, 176, 176) forKeyPath:@"_placeholderLabel.textColor"];
```

### **3.3.8 字典转模型**

字典转模型重要的两个点：

- 利用 Runtime 遍历所有的属性或者成员变量；
- 利用 KVC 设值。

下面简单实现了一个字典转模型的代码，通过 Runtime 遍历属性列表，并根据属性名取出字典中的对象，然后通过 KVC 进行赋值操作。调用方式和 MJExtension、YYModel 类似，直接通过模型类调用类方法即可。

```objectivec
- (instancetype)initWithDict:(NSDictionary *)dict {
    self = [super init];
    if (self) {
        unsigned int count = 0;
        objc_property_t *propertys = class_copyPropertyList([self class], &count);
        for (int i = 0; i < count; i++) {
            objc_property_t property = propertys[i];
//通过 property_getName 函数获得属性的名称const char *name = property_getName(property);
            NSString *nameStr = [[NSString alloc] initWithUTF8String:name];
            id value = [dict objectForKey:nameStr];
            [self setValue:value forKey:nameStr];
        }
        free(propertys);
    }
    return self;
}
```

有兴趣可以看看第三方模型转换库的横向对比（Mantle、MJExtension、YYModel 等）：[《iOS JSON 模型转换库评测》](https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/)。

### **3.3.9 替换方法实现**

替换方法实现常用的两个方法：

```objectivec
// 方法替换
IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
// 方法交换void method_exchangeImplementations(Method m1, Method m2)
```

例子：

```objectivec
// class_replaceMethod 替换成 imp_implementationWithBlock 中的内容
Person *person = [[Person alloc] init];
class_replaceMethod([Person class], @selector(test), imp_implementationWithBlock(^{
    NSlog(@"11");
}), "v");
[person test];
// run 和 test 相互替换
Method runMethod = class_getInstanceMethod([Person class], @selector(run));
Method testMethod = class_getInstanceMethod([Person class], @selector(test));
method_exchangeImplementations(runMethod, testMethod);
```

### **3.3.10 对象自动归档解档**

通过 Runtime 可以获取到对象的 `Method List`、`Property List` 等，不只可以用来做字典模型转换，还可以做很多工作。

例如：还可以通过 Runtime 实现自动归档和解档，归档和解档通俗来讲就是将数据写入文件和从文件中读取数据，这一块操作在 iOS 中是需要遵循相对应的协议的。

下面我们就来用代码实现一下：用 Runtime 提供的函数遍历 Model 自身所有属性，并对属性进行 `encode` 和 `decode` 操作。

```objectivec
- (id)initWithCoder:(NSCoder *)aDecoder {
    if (self = [super init]) {
        unsigned int outCount;
        Ivar * ivars = class_copyIvarList([self class], &outCount);
        for (int i = 0; i < outCount; i ++) {
            Ivar ivar = ivars[i];
            NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];
            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];
        }
    }
    return self;
}

- (void)encodeWithCoder:(NSCoder *)aCoder {
    unsigned int outCount;
    Ivar * ivars = class_copyIvarList([self class], &outCount);
    for (int i = 0; i < outCount; i ++) {
        Ivar ivar = ivars[i];
        NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];
        [aCoder encodeObject:[self valueForKey:key] forKey:key];
    }
}
```

### **3.3.11 给分类增加属性**

这里可以看我的博客 [《iOS 底层原理｜Category 本质》](https://www.cnblogs.com/qiuzhaohai/p/14584753.html) 中

> 五、 Caregory 通过关联对象添加成员变量

### **3.3.12 Runtime 关于类的 API**

```c
//动态创建一个类（参数：父类，类名，额外的内存空间）
Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
// 注册一个类（要在类注册之前添加成员变量）void objc_registerClassPair(Class cls)
// 销毁一个类void objc_disposeClassPair(Class cls)
// 获取isa指向的Class
Class object_getClass(id obj)
// 设置isa指向的Class
Class object_setClass(id obj, Class cls)
// 判断一个OC对象是否为Class
BOOL object_isClass(id obj)
// 判断一个Class是否为元类
BOOL class_isMetaClass(Class cls)
// 获取父类
Class class_getSuperclass(Class cls)
```

### **3.3.13 Runtime 关于成员变量的 API**

```c
// 获取一个实例变量信息
Ivar class_getInstanceVariable(Class cls, const char *name)
// 拷贝实例变量列表（最后需要调用free释放）
Ivar *class_copyIvarList(Class cls, unsigned int *outCount)
// 设置和获取成员变量的值void object_setIvar(id obj, Ivar ivar, id value)
id object_getIvar(id obj, Ivar ivar)
// 动态添加成员变量（已经注册的类是不能动态添加成员变量的）
BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)
// 获取成员变量的相关信息const char *ivar_getName(Ivar v)
const char *ivar_getTypeEncoding(Ivar v)
```

### **3.3.14 Runtime 关于属性的 API**

```c
// 获取一个属性objc_property_t class_getProperty(Class cls, const char *name)
// 拷贝属性列表（最后需要调用free释放）objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)
// 动态添加属性
BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,
                  unsigned int attributeCount)
// 动态替换属性void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,
                      unsigned int attributeCount)
// 获取属性的一些信息const char *property_getName(objc_property_t property)
const char *property_getAttributes(objc_property_t property)
```

### **3.3.15 Runtime 关于方法的 API**

```cpp
// 获得一个实例方法、类方法
Method class_getInstanceMethod(Class cls, SEL name)
Method class_getClassMethod(Class cls, SEL name)
// 方法实现相关操作
IMP class_getMethodImplementation(Class cls, SEL name)
IMP method_setImplementation(Method m, IMP imp)
void method_exchangeImplementations(Method m1, Method m2)
// 拷贝方法列表（最后需要调用free释放）
Method *class_copyMethodList(Class cls, unsigned int *outCount)
// 动态添加方法
BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
// 动态替换方法
IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
// 获取方法的相关信息（带有copy的需要调用free去释放）
SEL method_getName(Method m)
IMP method_getImplementation(Method m)
const char *method_getTypeEncoding(Method m)
unsigned int method_getNumberOfArguments(Method m)
char *method_copyReturnType(Method m)
char *method_copyArgumentType(Method m, unsigned int index)
// 选择器相关const char *sel_getName(SEL sel)
SEL sel_registerName(const char *str)
// 用block作为方法实现
IMP imp_implementationWithBlock(id block)
id imp_getBlock(IMP anImp)
BOOL imp_removeBlock(IMP anImp)
```

![image.png](attachment:d03ed72d-5be2-4556-89ca-0495cc2fc4ed:image.png)

# 4.Runloop

[https://blog.ibireme.com/2015/05/18/runloop/](https://blog.ibireme.com/2015/05/18/runloop/) ibireme的runloop介绍

# 5.多线程

# 6.网络知识

## 6.1 TCP 和 UDP

- `TCP面向连接`（如打电话要先拨号建立连接），`UDP是无连接`的，即发送数据之前不需要建立连接。
- `TCP提供可靠的服务`。也就是说，通过TCP连接传送的数据，**无差错、不丢失、不重复、且按序到达**。UDP则**尽最大努力交付，但不保证可靠交付**。
- TCP面向`字节流`。UDP是面向`报文`的。
- UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。
- TCP连接只能是`点到点`的。UDP连接支持`一对一、一对多、多对一和多对多`的交互通信。
- TCP的逻辑通信信道是全双工的`可靠信道`。UDP则是`不可靠信道`。

> TCP的优点：**数据传输可靠、稳定、保证数据顺序正确**。

> TCP的缺点：**数据传输慢、效率低、占用系统资源高、易被攻击**。

> UDP的优点：**数据传输快，比TCP相对安全**。

> UDP的缺点：**数据传输不可靠、不稳定、不保证顺序**。

## 6.2 三次握手&四次挥手

### 6.2.1 三次握手

第一次：客户端发送`SYN(同步)`包，请求建立连接。包中包含：`SYN = 1，seq = x`

第二次：服务端收到SYN包后，回复`SYN+ACK`包，表示同意连接。包中包含：`SYN = 1，ACK = 1， seq = y, ack = x+ 1`

第三次：客户端收到确认后，再发一个 `ACK` 包：`ACK=1`，`seq=x+1`，`ack=y+1`。

### 6.2.2 四次挥手

第一次：客户端发送 `FIN` 包，表示客户端没有数据要发了，但还可以接收：`FIN=1`，`seq=u`

第二次：服务器收到后回复 `ACK`，确认客户端的 `FIN`：`ACK=1`，`ack=u+1`。此时连接处于半关闭状态。

第三次：服务器准备好后，也发送一个 `FIN` 包，表示它也要断开：`FIN=1`，`seq=v`

第四次：客户端收到后，发送 `ACK` 确认：`ACK=1`，`ack=v+1`

# 7.体积App优化

1.移除无用的资源，如图片，静态库

2.压缩图片，使用webp格式

3.xcode开启图片压缩&移除坐着版权等信息

4.删除多余重复文件

5.资源图片放到asset里面，系统自动根据机型优化

6.删除未使用的代码，精简代码

8.根据版本需求，移除32位支持和armv7之前的架构

9.去掉symbol符号，不影响崩溃日志分析

10.上传ipa包时，开启App thinning

11.开启bitcode

12.部分可放到网络的资源，通过网络下载。

13.封装的framework，上线的版本，保留线上指令集 armv7s ， arm64

14.更合理的引用第三方，如只需要某种功能，fork后只引入所需的功能

# 8.APP启动优化

## 8.1 动态库dylib

1.分析APP内嵌依赖的动态库，**多个动态库合并。**

2.优化动态库的使用，官方建议在6个以内。

3.如果官方动态库framework在系统中已存在，设置为`required`，因为设置`optional`会有额外的检查。

4.使用静态库替代动态库，不过静态库会增大包体积。根据业务需求权衡

5.(了解)**指针重定位，**指针数量越少，指针修复的耗时也就越少。所以，优化该阶段的关键就是减少 `__DATA` 段中的指针数量

## 8.2优化文件、类

1.删除无效代码、类。（可以借助AppCode，不过当前AppCode已经不维护了）

2.减少Objc`类`、`方法`、`分类`的数量

3.减少C++虚函数（虚函数会创建 vtable，这也会在 `__DATA` 段中创建结构。）

4.Swift中多用结构体，（因为 Swift Structs 是静态分发的，它的结构内部做了优化，符号数量更少。）

## 8.3 类的优化

1.优化`+ (void)load`函数，应当避免使用

2.执行的任务延迟到 `+initialize` 中

## 8.4 其他

这里是`main()`函数之后的启动优化

1.避免使用`storyboard`、`xib`

2.延迟加载第三方库，移除NSLog

3.首页使用缓存数据

4.懒加载UI视图

5.压缩图片体积等

# 9. GCD

## 9.1 创建&使用串行队列

```objc
// 串行：DISPATCH_QUEUE_SERIAL   并行：DISPATCH_QUEUE_CONCURRENT
dispatch_queue_t serialQueue = dispatch_queue_create("SerialQueue", DISPATCH_QUEUE_SERIAL);
dispatch_async(serialQueue, ^{
		NSLog(@"1");
});
```

## 9.2 创建&使用并行队列

```objc
dispatch_queue_t concurrentQueue = dispatch_queue_create("ConcurrentQueue", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(concurrentQueue, ^{
		NSLog(@"1");
});
```

> 把任务放到并行队列中，不一定会开启新线程。要看当前已存在的线程执行情况。 串行队列，系统一定会开启一个新的线程。大量的开启会造成上下文切换消耗

- `QOS_CLASS_USER_INTERACTIVE` // 用于用户数据，希望快点返回
- `QOS_CLASS_USER_INITIATED` // 处理用户一般性数据
- `QOS_CLASS_DEFAULT` // 默认
- `QOS_CLASS_UTILITY` // 公共优先级偏低的
- `QOS_CLASS_BACKGROUND` //非常耗时的不重要数据

## 9.3 dispatch_group 组

```objc
dispatch_queue_t global = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, global, ^{
		sleep(1);
		NSLog(@"1");
});
dispatch_group_async(group, global, ^{
		sleep(1);
		NSLog(@"2");
});
dispatch_group_notify(group, global, ^{
		sleep(1);
		NSLog(@"finish!");
});
// 也可以用 dispatch_group_wait来替代相同效果
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
NSLog(@"finish!");
```

## 9.4 dispatch_barrier_async 栏栅函数

```objc
dispatch_queue_t global = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
dispatch_async( global, ^{
		sleep(1);
		NSLog(@"1");
});
dispatch_barrier_async(global, ^{
		sleep(3);
		NSLog(@"barrier");
});
NSLog(@"finish!");
dispatch_async( global, ^{
		sleep(1);
		NSLog(@"11");
});
```

## 9.5 dispatch_apply 快速迭代

```objectivec
dispatch_queue_t global = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
dispatch_apply(100, global, ^(size_t iteration) {
		sleep(1);
		NSLog(@"%lu",iteration);
});
NSLog(@"finish!");
```

## 9.6 dispatch_semaphore

```objectivec
// 建议使用Cpp的方式或者@property中用strong来修饰
_semaphore = dispatch_semaphore_create(1); // 代表了允许通过的线程数
// -------
- (void)concurrent:(int)idx{
		dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER); // 信号 -1 ， 如果小于0 就会阻塞
		sleep(1);
		NSLog(@"%d",idx);
		dispatch_semaphore_signal(_semaphore);
}
```

# **10. NSOperation**

## 10.1 NSBlockOperation

```objectivec
// 在 NSBlockOperation 初始化的任务不会开启线程
-(void)blockOperationDemo{
    NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i < 5; i++) {
            [NSThread sleepForTimeInterval:2];
            NSLog(@"%d--%@",i,[NSThread currentThread]);
        }
    }];
    [operation start];
}
// 新添加的任务会开启线程
[operation addExecutionBlock:^{
    for (int i = 0; i < 2; i++) {
        [NSThread sleepForTimeInterval:2];
        NSLog(@"executionBlock1--%@", [NSThread currentThread]);
    }
 }];
 [operation start]; // 记得开启
 // 如果调用了 addExecutionBlock 之后，初始化的任务依然在当前线程
```

## 10.2 使用NSOperationQueue

![image.png](attachment:c9ada71b-e331-4938-9710-235518e89279:image.png)

![image.png](attachment:70df92eb-8721-4fdd-8f14-1894600e969b:image.png)

# 11. 自动释放池

1.主线程的自动释放池是由主线程的Runloop控制，Runloop开始时创建新的自动释放池，Runloop一次循环结束时倾倒池子向池子的对象发送一次release消息，并创建**新的**池子。

2.子线程的并不会创建自动释放池，需要我们手动自己创建，对象是在线程执行完毕后释放。

3.GCD的每一次任务，系统会默认帮我们加上自动释放池。

[设计模式](https://www.notion.so/2422b7ed6b4d8095b43bf99f2134b8d7?pvs=21)

[Swift基类参考](https://www.notion.so/Swift-2492b7ed6b4d80fab144e39458e47799?pvs=21)

[Combine](https://www.notion.so/Combine-24d2b7ed6b4d808c8c67d51c325248a2?pvs=21)