
快速的使用场景以及建议

| 设计模式 | 适用场景 |
| --- | --- |
| **单例** | 全局唯一对象（如配置管理、数据库连接、日志管理等） |
| **工厂方法** | 创建对象时需要灵活扩展具体类，且客户端只依赖抽象接口 ，`根据不同的枚举创建子类/无限派生子类` |
| **抽象工厂** | 需要创建一系列相关或相互依赖的对象族，且无需指定具体类 `将工厂和产品都抽象化` |
| **建造者** | 复杂对象的分步构造，且构造过程稳定但表示可变（如构建复杂UI、网络请求参数）`分配构造，其余默认参数` |
| **原型** | 需要通过拷贝已有实例创建对象，避免重复构造，且对象创建成本高 `拷贝部分，注意要创建成本高` |
| **适配器** | 需要将一个类的接口转换成客户希望的另一个接口，解决接口不兼容问题 `添加一层包装，更符合整体` |
| **桥接** | 抽象与实现分离，可独立变化；多维度变化解耦，减少子类爆炸。`更解耦，更抽象` |
| **装饰器** | 需要动态扩展对象功能，替代子类继承，避免类爆炸。`为类扩展更多的功能` |
| **外观** | 为复杂子系统提供简单接口，降低耦合，方便调用。`封装单个调用一堆，如用Config类来加载日志、崩溃监测` |
| **组合** | 对象树形结构的表示，统一对待单个对象和组合对象。`UIView和SubViews` |
| **享元** | 系统中存在大量相似对象，且可共享相同部分状态，节约内存 `UITableViewCell 重用` |
| **代理** | 控制对真实对象的访问（远程、延迟加载、权限控制等） |
| **责任链** | 多个对象可处理请求，按链式传递请求，避免请求发送者和接收者耦合.`如请假流程本级处理完成，丢给下一级。GPUImage` |
| **命令** | 请求封装成对象，支持请求排队、日志、撤销等 |
| **解释器** | 实现特定语言的解析与执行，语法规则封装为类 |
| **迭代器** | 顺序访问聚合对象元素，而不暴露其内部表示 |
| **中介者** | 复杂对象之间交互集中管理，降低对象间耦合。`如聊天室，和群友属于有关系，但我们应和聊天室交互` |
| **备忘录** | *需要保存和恢复对象状态，实现撤销功能* |
| **观察者** | 一对多依赖关系，状态变化自动通知观察者 |
| **状态** | 对象行为依赖状态，状态改变影响行为，实现状态切换。`如播放器到多种状态，由contaxt记录当前状态来处理操作` |
| **策略** | 定义一系列算法，客户端可**动态切换算法。**`如支持多种支付方式，某一种失败动态切换到另外一种` |
| **模板方法** | 定义算法骨架，部分步骤由子类实现，复用不变流程，`如UIViewController的viewDidLoad` |
| **访问者** | 数据结构稳定，需要对结构中的元素执行不同操作，操作易扩展 |

# 1. 创建型模式

## 1.1 单例模式

```swift
class AppManager {
    static let shared = AppManager()
    private init() {}
}
```

## 1.2 工厂模式

1.**简单工厂**：使用枚举来返回类型。新增一个类型时，需要扩展枚举、新增类

2.**工厂模式**：每一个产品一个类型。

```swift
/// 简单工厂，使用switch来返回需要哪个类。扩展性稍差
enum ProductType {
    case a
    case b
}

class SimpleFactory {
    static func makeProduct(type: ProductType) -> Product {
        switch type {
        case .a: return ProductA()
        case .b: return ProductB()
        }
    }
}

protocol Product {
    func use()
}

class ProductA: Product {
    func use() { print("Using product A") }
}

class ProductB: Product {
    func use() { print("Using product B") }
}
/// 工厂模式

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        view.backgroundColor = .white
        
        let a = FactoryA()
        a.makeProduct()
        
        let b = FactoryB()
        b.makeProduct()
        
    }
}
protocol Factory {
    func makeProduct();
}

class FactoryA : Factory {
    func makeProduct() {
        print("make product A")
    }
}

class FactoryB : Factory {
    func makeProduct() {
        print("make product B")
    }
}
```

## 1.3 抽象工厂

创建一组相关对象

```swift
// 抽象产品
protocol Button {
    func render()
}

protocol Label {
    func show()
}

// 抽象工厂
protocol GUIFactory {
    func createButton() -> Button
    func createLabel() -> Label
}

// 具体产品 A
class iOSButton: Button {
    func render() { print("Render iOS Button") }
}
class iOSLabel: Label {
    func show() { print("Show iOS Label") }
}

// 具体产品 B
class AndroidButton: Button {
    func render() { print("Render Android Button") }
}
class AndroidLabel: Label {
    func show() { print("Show Android Label") }
}

// 具体工厂 A
class iOSFactory: GUIFactory {
    func createButton() -> Button { iOSButton() }
    func createLabel() -> Label { iOSLabel() }
}

// 具体工厂 B
class AndroidFactory: GUIFactory {
    func createButton() -> Button { AndroidButton() }
    func createLabel() -> Label { AndroidLabel() }
}
```

## 1.4 建造者模式

- 对象构建过程复杂，步骤多（比如 `NSAttributedString`，`NSMutableURLRequest`）
- 想要链式调用提高可读性
- 想构造不同类型或样式的对象，但构建过程类似

通过创建一个构造器，来分步骤构建复杂对象。

```swift
// 产品类--要构造的对象
class CustomView {
    var backgroundColor: UIColor?
    var cornerRadius: CGFloat = 0
    var borderWidth: CGFloat = 0
    var borderColor: UIColor?

    func showConfig() {
        print("背景色：\(backgroundColor?.description ?? "nil")，圆角：\(cornerRadius)，边框：\(borderWidth)，边框颜色：\(borderColor?.description ?? "nil")")
    }
}
// 创建构造器
class CustomViewBuilder {
    private var view = CustomView()
    
    func setBackgroundColor(_ color: UIColor) -> CustomViewBuilder {
        view.backgroundColor = color
        return self
    }
    
    func setCornerRadius(_ radius: CGFloat) -> CustomViewBuilder {
        view.cornerRadius = radius
        return self
    }
    
    func setBorder(width: CGFloat, color: UIColor) -> CustomViewBuilder {
        view.borderWidth = width
        view.borderColor = color
        return self
    }
    
    func build() -> CustomView {
        return view
    }
}
let myView = CustomViewBuilder()
    .setBackgroundColor(.blue)
    .setCornerRadius(8)
    .setBorder(width: 1, color: .gray)
    .build()

myView.showConfig()
// 输出：背景色：UIDeviceRGBColorSpace 0 0 1 1，圆角：8.0，边框：1.0，边框颜色：UIDeviceWhiteColorSpace 0.5 1

```

## 1.5 原型模式

- 创建对象的成本比较高（初始化耗时或过程复杂）
- 你希望复制的对象包含当前所有状态
- 希望避免构造函数中的逻辑执行

```swift
class Document: NSCopying {
    var text: String
    var images: [String]
    
    init(text: String, images: [String]) {
        self.text = text
        self.images = images
    }
    
    func copy(with zone: NSZone? = nil) -> Any {
        let copy = Document(text: self.text, images: self.images)
        return copy
    }
    
    func show() {
        print("文本：\(text)，图片：\(images)")
    }
}
```

# 2. 结构性模式

## 2.1 适配器模式

适配器模式（**Adapter Pattern**）是结构型设计模式的一种，**用于将一个类的接口转换成客户端期望的另一个接口**。它就像电源插头的“转换器” —— 让本来不兼容的接口能够协同工作。

- 已有系统中的类接口不符合新的客户端需求
- 你想复用一些旧类，但又不想改动它们
- 你在用第三方库，但接口不友好

```swift
// 旧的功能只能播放mp3
class MP3Player {
    func playMP3(fileName: String) {
        print("播放 MP3 文件: \(fileName)")
    }
}
protocol AudioPlayer {
    func play(fileName: String)
}
class MP3Adapter: AudioPlayer {
    private let mp3Player = MP3Player()
    
    func play(fileName: String) {
        if fileName.hasSuffix(".mp3") {
            mp3Player.playMP3(fileName: fileName)
        } else {
            print("无法播放此格式: \(fileName)")
        }
    }
}
/// 使用场景
let player: AudioPlayer = MP3Adapter()
player.play(fileName: "music.mp3")
player.play(fileName: "song.flac")
```

## 2.2 桥接模式

将抽象部分与它的实现部分分离，使它们都可以独立地变化。

桥接模式和适配器不同。适配器是**兼容已有接口**，而桥接模式是**主动设计接口分离，面向扩展**。

```swift
// 实现部分
protocol Renderer {
    func renderCircle(radius: Double)
}
class MetalRenderer: Renderer {
    func renderCircle(radius: Double) {
        print("Using Metal to render a circle with radius \(radius)")
    }
}

class OpenGLRenderer: Renderer {
    func renderCircle(radius: Double) {
        print("Using OpenGL to render a circle with radius \(radius)")
    }
}
class Shape {
    let renderer: Renderer
    init(renderer: Renderer) {
        self.renderer = renderer
    }
    func draw() {
        // 留空，由子类实现
    }
}
class Circle: Shape {
    let radius: Double
    init(renderer: Renderer, radius: Double) {
        self.radius = radius
        super.init(renderer: renderer)
    }
    
    override func draw() {
        renderer.renderCircle(radius: radius)
    }
}
// 使用
let metal = MetalRenderer()
let circle1 = Circle(renderer: metal, radius: 10)
circle1.draw()

let opengl = OpenGLRenderer()
let circle2 = Circle(renderer: opengl, radius: 20)
circle2.draw()

```

## 2.3 装饰器模式

装饰器模式（**Decorator Pattern**）是结构型设计模式之一，用于**在不修改原始对象的前提下，动态地扩展其功能**

```swift
protocol Text {
    func display() -> String
}
class PlainText: Text {
    private let content: String

    init(_ content: String) {
        self.content = content
    }

    func display() -> String {
        return content
    }
}
class TextDecorator: Text {
    private let wrapped: Text

    init(_ wrapped: Text) {
        self.wrapped = wrapped
    }

    func display() -> String {
        return wrapped.display()
    }
}
class BoldText: TextDecorator {
    override func display() -> String {
        return "<b>" + super.display() + "</b>"
    }
}

class UnderlineText: TextDecorator {
    override func display() -> String {
        return "<u>" + super.display() + "</u>"
    }
}

class RedText: TextDecorator {
    override func display() -> String {
        return "<font color='red'>" + super.display() + "</font>"
    }
}
// 使用
let text = PlainText("Hello")
let bold = BoldText(text)
let underline = UnderlineText(bold)
let red = RedText(underline)

print(red.display())

```

## 2.4 外观模式

封装复杂子系统、提供统一入口、解耦客户端与子系统之间的依赖关系

```swift
class ConfigManager {
    func loadConfig() {
        print("配置已加载")
    }
}

class LogManager {
    func setupLogger() {
        print("日志系统已初始化")
    }
}

class NetworkManager {
    func setupNetwork() {
        print("网络系统已准备")
    }
}

class UserManager {
    func checkLoginStatus() {
        print("用户登录状态已检查")
    }
}
class AppFacade {
    private let config = ConfigManager()
    private let logger = LogManager()
    private let network = NetworkManager()
    private let user = UserManager()
    
    func initializeApp() {
        config.loadConfig()
        logger.setupLogger()
        network.setupNetwork()
        user.checkLoginStatus()
    }
}
// 使用
let app = AppFacade()
app.initializeApp()
```

## 2.5 组合模式

组合模式（**Composite Pattern**）是一种结构型设计模式，用于将对象组合成树形结构以表示“**部分-整体**”的层次结构。

它使得客户端对单个对象和组合对象具有**一致的访问方式**。

eg。所有视图都继承自 `UIView`，你可以对 `rootView` 进行统一操作，而不管它内部有多少子视图，这就是组合模式。

```swift
let rootView = UIView()
let button = UIButton()
let label = UILabel()
rootView.addSubview(button)
rootView.addSubview(label)
```

```swift
protocol Employee {
    func showDetails()
}
class Developer: Employee {
    private let name: String
    init(name: String) {
        self.name = name
    }

    func showDetails() {
        print("开发人员: \(name)")
    }
}
class Manager: Employee {
    private let name: String
    private var subordinates: [Employee] = []

    init(name: String) {
        self.name = name
    }

    func addSubordinate(_ employee: Employee) {
        subordinates.append(employee)
    }

    func showDetails() {
        print("经理: \(name)")
        for employee in subordinates {
            employee.showDetails()
        }
    }
}
// 使用
let dev1 = Developer(name: "Alice")
let dev2 = Developer(name: "Bob")

let teamLead = Manager(name: "Charlie")
teamLead.addSubordinate(dev1)
teamLead.addSubordinate(dev2)

let cto = Manager(name: "Diana")
cto.addSubordinate(teamLead)

cto.showDetails()
```

## 2.6 享元模式

共享对象降低内存，如`UITableViewCell`

## 2.7 代理模式

/

# 3. 行为模式

## 3.1 责任链模式

责任链模式（**Chain of Responsibility Pattern**）是一种**行为型设计模式**，它使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

- **将请求沿着处理链传递**
- 每个节点可以：
    - **处理请求**
    - **将请求传递给下一个节点**

类似UIView的事件响应链

```swift
/// 定义当前节点
class LeaveRequest {
    let name: String
    let days: Int

    init(name: String, days: Int) {
        self.name = name
        self.days = days
    }
}
/// 协议，能够访问到下一个节点
protocol LeaveHandler {
    var next: LeaveHandler? { get set }
    func handle(request: LeaveRequest)
}
class TeamLead: LeaveHandler {
    var next: LeaveHandler?

    func handle(request: LeaveRequest) {
        if request.days <= 2 {
            print("TeamLead 批准 \(request.name) 请假 \(request.days) 天")
        } else {
            next?.handle(request: request)
        }
    }
}

class Manager: LeaveHandler {
    var next: LeaveHandler?

    func handle(request: LeaveRequest) {
        if request.days <= 5 {
            print("Manager 批准 \(request.name) 请假 \(request.days) 天")
        } else {
            next?.handle(request: request)
        }
    }
}

class CEO: LeaveHandler {
    var next: LeaveHandler?

    func handle(request: LeaveRequest) {
        print("CEO 批准 \(request.name) 请假 \(request.days) 天")
    }
}
/// 使用
let teamLead = TeamLead()
let manager = Manager()
let ceo = CEO()

teamLead.next = manager
manager.next = ceo

let request1 = LeaveRequest(name: "Tom", days: 1)
let request2 = LeaveRequest(name: "Jerry", days: 4)
let request3 = LeaveRequest(name: "Bob", days: 10)

teamLead.handle(request: request1)
teamLead.handle(request: request2)
teamLead.handle(request: request3)
// 输出打印
/*
TeamLead 批准 Tom 请假 1 天
Manager 批准 Jerry 请假 4 天
CEO 批准 Bob 请假 10 天
*/
```

## 3.2 命令模式

命令模式（**Command Pattern**）是一种**行为型设计模式**，它将**请求封装成对象**，从而允许你**将请求参数化、排队、记录日志**，并支持**撤销操作**等。

```swift
// 定义命令协议
protocol Command {
    func execute()
    func undo()
}
// 接收者（执行具体逻辑的对象）
class Light {
    func turnOn() {
        print("💡 Light is ON")
    }

    func turnOff() {
        print("💡 Light is OFF")
    }
}
//具体命令类
class LightOnCommand: Command {
    private let light: Light

    init(light: Light) {
        self.light = light
    }

    func execute() {
        light.turnOn()
    }

    func undo() {
        light.turnOff()
    }
}

class LightOffCommand: Command {
    private let light: Light

    init(light: Light) {
        self.light = light
    }

    func execute() {
        light.turnOff()
    }

    func undo() {
        light.turnOn()
    }
}
//  调用者（遥控器）
class RemoteControl {
    private var command: Command?
    private var history: [Command] = []

    func setCommand(_ command: Command) {
        self.command = command
    }

    func pressButton() {
        command?.execute()
        if let cmd = command {
            history.append(cmd)
        }
    }

    func pressUndo() {
        guard let last = history.popLast() else { return }
        last.undo()
    }
}
/// 使用示例
let light = Light()
let lightOn = LightOnCommand(light: light)
let lightOff = LightOffCommand(light: light)

let remote = RemoteControl()

remote.setCommand(lightOn)
remote.pressButton()     // 💡 Light is ON

remote.setCommand(lightOff)
remote.pressButton()     // 💡 Light is OFF

remote.pressUndo()       // 💡 Light is ON
```

## 3.3 解释器模式

解释器模式（**Interpreter Pattern**）是一种**行为型设计模式**，用于**定义一种语言的语法表示**，并**构建一个解释器**来解释或执行该语言中的句子

```swift
protocol Expression {
    func interpret(context: [String: Bool]) -> Bool
}
//  实现终结符表达式（变量）
class VariableExpression: Expression {
    private let name: String

    init(_ name: String) {
        self.name = name
    }

    func interpret(context: [String: Bool]) -> Bool {
        return context[name] ?? false
    }
}
// 实现非终结符表达式（AND、OR、NOT）
class AndExpression: Expression {
    private let left: Expression
    private let right: Expression

    init(_ left: Expression, _ right: Expression) {
        self.left = left
        self.right = right
    }

    func interpret(context: [String: Bool]) -> Bool {
        return left.interpret(context: context) && right.interpret(context: context)
    }
}

class OrExpression: Expression {
    private let left: Expression
    private let right: Expression

    init(_ left: Expression, _ right: Expression) {
        self.left = left
        self.right = right
    }

    func interpret(context: [String: Bool]) -> Bool {
        return left.interpret(context: context) || right.interpret(context: context)
    }
}

class NotExpression: Expression {
    private let expr: Expression

    init(_ expr: Expression) {
        self.expr = expr
    }

    func interpret(context: [String: Bool]) -> Bool {
        return !expr.interpret(context: context)
    }
}
// 使用示例
// 表达式：(A AND B) OR (NOT C)

let A = VariableExpression("A")
let B = VariableExpression("B")
let C = VariableExpression("C")

let expr = OrExpression(
    AndExpression(A, B),
    NotExpression(C)
)

let context: [String: Bool] = [
    "A": true,
    "B": false,
    "C": false
]

print(expr.interpret(context: context)) // 输出 true

```

## 3.4 迭代器模式

迭代器模式（**Iterator Pattern**）是一种**行为型设计模式**，用于提供一种方法**顺序访问一个聚合对象中的元素**，而**不暴露其内部表示**。

- 想要遍历集合类（数组、链表、自定义容器）；
- 不希望让调用者知道集合的内部结构（封装性）；
- 需要多个遍历方式或并发遍历。

在 Swift 中，标准库已经大量使用了迭代器模式，比如 `Array`、`Set`、`Dictionary` 都遵循了 `Sequence` 和 `IteratorProtocol`。

```swift
protocol Iterator {
    associatedtype Element
    func hasNext() -> Bool
    func next() -> Element?
}
// 自定义聚合类
class BookShelf {
    private var books: [String] = []

    func append(book: String) {
        books.append(book)
    }

    func bookAt(index: Int) -> String {
        return books[index]
    }

    func count() -> Int {
        return books.count
    }

    func makeIterator() -> BookShelfIterator {
        return BookShelfIterator(self)
    }
}
// 具体迭代器的实现
class BookShelfIterator: Iterator {
    private let bookShelf: BookShelf
    private var index = 0

    init(_ bookShelf: BookShelf) {
        self.bookShelf = bookShelf
    }

    func hasNext() -> Bool {
        return index < bookShelf.count()
    }

    func next() -> String? {
        guard hasNext() else { return nil }
        let book = bookShelf.bookAt(index: index)
        index += 1
        return book
    }
}
// 使用示例
let shelf = BookShelf()
shelf.append(book: "Design Patterns")
shelf.append(book: "Refactoring")
shelf.append(book: "Clean Code")

let iterator = shelf.makeIterator()
while iterator.hasNext() {
    print(iterator.next()!)
}
// 输出：
// Design Patterns
// Refactoring
// Clean Code

```

## 3.5 中介者模式

中介者模式（**Mediator Pattern**）是一种**行为型设计模式**，用于**封装对象之间的交互行为**，使多个对象不必显式相互引用，从而使耦合松散、交互集中。

将对象之间的交互逻辑集中到一个中介者中，让各个对象不再直接引用彼此，而是通过中介者协调通信。

```markdown
             ┌──────────────┐
             │   Mediator   │◀─────────────┐
             └─────▲────────┘              │
                   │                       │
        ┌──────────┴──────────┐  ┌─────────┴───────────┐
        │ ConcreteColleagueA  │  │ ConcreteColleagueB  │
        └──────────▲──────────┘  └─────────▲───────────┘
                   │                       │
           ┌───────┴────────┐      ┌───────┴─────────┐
           │ ConcreteMediator│────▶│协调具体通信逻辑 │
           └────────────────┘      └─────────────────┘
```

- 多个对象之间存在复杂的交互，且对象之间相互引用；
- 希望将交互行为集中管理，避免对象之间网状引用（解耦）；
- 常用于聊天系统、表单交互、组件通信等场景。

```swift
// 定义中介协议(聊天室功能)
protocol ChatMediator {
    func send(message: String, from user: User)
    func addUser(_ user: User)
}
// 在定义用户类
class User {
    let name: String
    private let mediator: ChatMediator

    init(name: String, mediator: ChatMediator) {
        self.name = name
        self.mediator = mediator
    }

    func send(message: String) {
        print("[\(name)] 发送消息：\(message)")
        mediator.send(message: message, from: self)
    }

    func receive(message: String, from sender: String) {
        print("[\(name)] 收到来自 [\(sender)] 的消息：\(message)")
    }
}
// 实现中介者
class ChatRoomMediator: ChatMediator {
    private var users: [User] = []

    func addUser(_ user: User) {
        users.append(user)
    }

    func send(message: String, from user: User) {
        for u in users where u.name != user.name {
            u.receive(message: message, from: user.name)
        }
    }
}
//使用中介者协调通信
let mediator = ChatRoomMediator()

let alice = User(name: "Alice", mediator: mediator)
let bob = User(name: "Bob", mediator: mediator)
let charlie = User(name: "Charlie", mediator: mediator)

mediator.addUser(alice)
mediator.addUser(bob)
mediator.addUser(charlie)

alice.send(message: "Hi everyone!")
bob.send(message: "Hello Alice!")
/*
[Alice] 发送消息：Hi everyone!
[Bob] 收到来自 [Alice] 的消息：Hi everyone!
[Charlie] 收到来自 [Alice] 的消息：Hi everyone!
[Bob] 发送消息：Hello Alice!
[Alice] 收到来自 [Bob] 的消息：Hello Alice!
[Charlie] 收到来自 [Bob] 的消息：Hello Alice!
*/
```

## 3.6 备忘录模式

备忘录模式（**Memento Pattern**）是一种**行为型设计模式**，用于**保存对象在某一时刻的状态**，以便在将来恢复到这个状态。该模式常用于实现“撤销/恢复”功能。

在不破坏封装的前提下，**捕获并保存一个对象的内部状态**，以便在需要时可以恢复该状态。

```swift
┌───────────────┐
│  Originator   │────────────┐
│（发起者）      │            │
└──────┬────────┘            │
       │ createMemento()     ▼
       │ restore(memento) ┌────────────┐
       └─────────────────▶│  Memento   │
                          │（备忘录）   │
                          └────┬───────┘
                               │
                               ▼
                      ┌────────────────┐
                      │ Caretaker      │
                      │（负责人）        │
                      └────────────────┘
```

```swift
// 定义备忘录类
class TextMemento {
    let state: String
    
    init(state: String) {
        self.state = state
    }
}
//定义 Originator（发起者）
class TextEditor {
    private var content: String = ""
    
    func type(text: String) {
        content += text
    }

    func getContent() -> String {
        return content
    }

    func save() -> TextMemento {
        return TextMemento(state: content)
    }

    func restore(from memento: TextMemento) {
        self.content = memento.state
    }
}
//  定义 Caretaker（负责人）
class History {
    private var states: [TextMemento] = []

    func push(_ memento: TextMemento) {
        states.append(memento)
    }

    func pop() -> TextMemento? {
        return states.popLast()
    }
}
// 使用备忘录实现撤销
let editor = TextEditor()
let history = History()

editor.type(text: "Hello, ")
history.push(editor.save())

editor.type(text: "world!")
history.push(editor.save())

editor.type(text: " Goodbye.") // 没保存

print("当前内容：\(editor.getContent())") // Hello, world! Goodbye.

if let lastState = history.pop() {
    editor.restore(from: lastState)
    print("撤销一次后内容：\(editor.getContent())") // Hello, world!
}

if let lastState = history.pop() {
    editor.restore(from: lastState)
    print("撤销两次后内容：\(editor.getContent())") // Hello,
}
```

 **优点**

- 不暴露对象内部状态；
- 恢复对象状态非常简单；
- 支持撤销操作。

---

**🧱 缺点**

- 如果对象状态很大，频繁保存会占用大量内存；
- 备忘录管理不好会造成资源泄漏或过多占用。

## 3.7 观察者模式

## 3.8 状态模式

状态模式（**State Pattern**）是一种行为型设计模式，它允许一个对象在其**内部状态发生改变时，改变它的行为**，使得对象看起来像是修改了它的类一样。

```swift
┌────────────┐
│ Context    │◀────────┐
│（上下文）   │         │
└────┬───────┘         │
     │setState()       │
     ▼                 │
┌────────────┐    ┌────────────┐
│ StateA     │    │ StateB     │
│（具体状态） │    │（具体状态） │
└────────────┘    └────────────┘
         ▲                ▲
         └─────实现───────┘
              ↑
         ┌────────────┐
         │  State     │
         │（状态接口） │
         └────────────┘
```

```swift
protocol PlayerState {
    func play(context: PlayerContext)
    func pause(context: PlayerContext)
    func stop(context: PlayerContext)
}
/// 转换类
class PlayingState: PlayerState {
    func play(context: PlayerContext) {
        print("已经在播放")
    }

    func pause(context: PlayerContext) {
        print("暂停播放")
        context.state = PausedState()
    }

    func stop(context: PlayerContext) {
        print("停止播放")
        context.state = StoppedState()
    }
}

class PausedState: PlayerState {
    func play(context: PlayerContext) {
        print("继续播放")
        context.state = PlayingState()
    }

    func pause(context: PlayerContext) {
        print("已经暂停")
    }

    func stop(context: PlayerContext) {
        print("停止播放")
        context.state = StoppedState()
    }
}

class StoppedState: PlayerState {
    func play(context: PlayerContext) {
        print("开始播放")
        context.state = PlayingState()
    }

    func pause(context: PlayerContext) {
        print("不能暂停，当前已停止")
    }

    func stop(context: PlayerContext) {
        print("已经停止")
    }
}
// 定义上下文
class PlayerContext {
    var state: PlayerState

    init(state: PlayerState) {
        self.state = state
    }

    func play() {
        state.play(context: self)
    }

    func pause() {
        state.pause(context: self)
    }

    func stop() {
        state.stop(context: self)
    }
}
// 使用示例
let player = PlayerContext(state: StoppedState())

player.play()   // 输出：开始播放
player.pause()  // 输出：暂停播放
player.play()   // 输出：继续播放
player.stop()   // 输出：停止播放
player.pause()  // 输出：不能暂停，当前已停止

```

## 3.9 策略模式

策略模式（**Strategy Pattern**）是一种行为型设计模式，它定义了一系列算法，把它们一个个封装起来，并且使它们可以互换使用。**策略模式让算法独立于使用它的客户端独立变化。**

场景：我们需要支持不同支付方式（微信、支付宝、银行卡），可以灵活切换。

```swift
┌────────────┐
│ Context    │
│（上下文）   │
└────┬───────┘
     │ has-a
     ▼
┌────────────┐
│ Strategy   │◄────────┐
│（策略接口） │         │
└────┬───────┘         │
     │                 │
 ┌───▼────────┐   ┌────▼───────┐
 │ ConcreteA  │   │ ConcreteB  │
 │（具体策略） │   │（具体策略） │
 └────────────┘   └────────────┘
```

```swift
protocol PaymentStrategy {
    func pay(amount: Double)
}
/// 实现不同的策略
class WeChatPay: PaymentStrategy {
    func pay(amount: Double) {
        print("使用微信支付 \(amount) 元")
    }
}

class Alipay: PaymentStrategy {
    func pay(amount: Double) {
        print("使用支付宝支付 \(amount) 元")
    }
}

class BankCardPay: PaymentStrategy {
    func pay(amount: Double) {
        print("使用银行卡支付 \(amount) 元")
    }
}
/// 上下文类
class PaymentContext {
    private var strategy: PaymentStrategy

    init(strategy: PaymentStrategy) {
        self.strategy = strategy
    }

    func setStrategy(_ strategy: PaymentStrategy) {
        self.strategy = strategy
    }

    func pay(amount: Double) {
        strategy.pay(amount: amount)
    }
}
// 使用示例
let context = PaymentContext(strategy: WeChatPay())
context.pay(amount: 100.0)   // 输出：使用微信支付 100.0 元

context.setStrategy(Alipay())
context.pay(amount: 200.0)   // 输出：使用支付宝支付 200.0 元

context.setStrategy(BankCardPay())
context.pay(amount: 300.0)   // 输出：使用银行卡支付 300.0 元

```

## 3.10 模版模式

模板方法模式是一种**行为型设计模式**，它在父类中定义一个算法的**骨架**，将一些步骤的实现延迟到子类中。**子类可以重新定义某些步骤的实现，而无需改变算法的结构。**

```swift
class BaseViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        bindData()
        fetchData()
    }

    func setupUI() {
        // 子类重写
    }

    func bindData() {
        // 子类重写
    }

    func fetchData() {
        // 子类重写
    }
}
// 子类实现具体的步骤
class UserViewController: BaseViewController {

    override func setupUI() {
        print("设置用户界面")
    }

    override func bindData() {
        print("绑定用户数据")
    }

    override func fetchData() {
        print("从网络请求用户数据")
    }
}

```

## 3.11 访问者模式

它让你可以在不修改元素类的前提下，**向这些类中添加新的操作（方法）**。

它将**数据结构与行为操作分离**，当你有稳定的数据结构，但频繁变动的操作时，使用访问者模式特别合适。

```swift
┌───────────────┐      ┌────────────┐
│   Visitor     │◄─────│  ConcreteVisitorA/B │
└─────▲─────────┘      └────────────┘
      │
┌─────┴──────────┐
│   Element      │
│+accept(v:Visitor)│
└─────▲──────────┘
      │
 ┌────┴─────┐
 │ Concrete │
 │ ElementA │
 └──────────┘
```

你有多个图形类，比如 `Circle`、`Rectangle`，你想实现多个行为：**绘制、导出、分析大小等**，你不希望把这些行为都塞进图形类中，而是**用访问者来封装它们**。

```swift
// 定义访问者协议（Visitor）
protocol ShapeVisitor {
    func visit(circle: Circle)
    func visit(rectangle: Rectangle)
}
// 定义图形协议
protocol Shape {
    func accept(visitor: ShapeVisitor)
}
// 具体图形类
class Circle: Shape {
    let radius: Double
    
    init(radius: Double) {
        self.radius = radius
    }
    
    func accept(visitor: ShapeVisitor) {
        visitor.visit(circle: self)
    }
}

class Rectangle: Shape {
    let width: Double
    let height: Double
    
    init(width: Double, height: Double) {
        self.width = width
        self.height = height
    }
    
    func accept(visitor: ShapeVisitor) {
        visitor.visit(rectangle: self)
    }
}
// 一个访问者（绘图）
class DrawVisitor: ShapeVisitor {
    func visit(circle: Circle) {
        print("绘制一个半径为 \(circle.radius) 的圆")
    }
    
    func visit(rectangle: Rectangle) {
        print("绘制一个宽 \(rectangle.width)，高 \(rectangle.height) 的矩形")
    }
}
// 使用示例
let shapes: [Shape] = [
    Circle(radius: 10),
    Rectangle(width: 20, height: 15)
]

let drawer = DrawVisitor()

for shape in shapes {
    shape.accept(visitor: drawer)
}
```