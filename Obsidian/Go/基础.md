### 获取当前时间

```go
func getTimeStr() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

fmt.Printf("current time str : %s\\n", getTimeStr())
```

### chan

```go
// 声明不带缓冲的通道
ch1 := make(chan string)

// 声明带10个缓冲的通道
ch2 := make(chan string, 10)

// 声明只读通道
ch3 := make(<-chan string)

// 声明只写通道
ch4 := make(chan<- string)
```

### interface

```go
package study

import "github.com/pkg/errors"

var _ Study = (*study)(nil)

type Study interface {
	Listen(msg string) string
	Speak(msg string) string
	Read(msg string) string
	Write(msg string) string
}

type study struct {
	Name string
}

func (s *study) Listen(msg string) string {
	return s.Name + " 听 " + msg
}

func (s *study) Speak(msg string) string {
	return s.Name + " 说 " + msg
}

func (s *study) Read(msg string) string {
	return s.Name + " 读 " + msg
}

func (s *study) Write(msg string) string {
	return s.Name + " 写 " + msg
}

func New(name string) (Study, error) {
	if name == "" {
		return nil, errors.New("name required")
	}

	return &study{
		Name: name,
	}, nil
}
```

### 字符串

不要使用 `+` 和 `fmt.Sprintf` 操作字符串，虽然很方便，但是真的很慢！

我们要使用 `bytes.NewBufferString` 进行处理

```go
text := bytes.NewBufferString("你好")
fmt.Println(text)

text.WriteString(", 好的")
fmt.Println(text)
```

### map

对于固定字段的键值对，不要使用 `map[string]interface{}`

```go
func BenchmarkStructOperation2(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var demo struct {
			Name string
			Age  int
		}
		demo.Name = "Tom"
		demo.Age = 30
	}
}
```

### sync.poor

`sync.Pool` 是临时对象池，存储的是临时对象，不可以用它来存储 `socket` 长连接和数据库连接池等。

`sync.Pool` 本质是用来保存和复用临时对象，以减少内存分配，降低 GC 压力，比如需要使用一个对象，就去 Pool 里面拿，如果拿不到就分配一份，这比起不停生成新的对象，用完了再等待 GC 回收要高效的多。

```go
package student

import (
	"sync"
)

type student struct {
	Name string
	Age  int
}

var studentPool = &sync.Pool{
	New: func() interface{} {
		return new(student)
	},
}

func New(name string, age int) *student {
	stu := studentPool.Get().(*student) // (*student) 由于创建的是一个interface类型，这里断言为student的引用类型
	stu.Name = name
	stu.Age = age
	return stu
}

func Release(stu *student) {
	stu.Name = ""
	stu.Age = 0
	studentPool.Put(stu)
}
```

当使用 `student` 对象时，只需要调用 `New()` 方法获取对象，获取之后使用 `defer` 函数进行释放即可。

1. 一定要注意 `Get` 后，要调用 `Put` ！

### 逃逸分析

```bash
go run -gcflags '-m -l' main.go
```

`interface{}` 赋值，会发生逃逸，优化方案是将类型设置为固定类型，例如：`string`

### sync.map

1. `Load` 加载 key 数据
2. `Store` 更新或新增 key 数据
3. `Delete` 删除 key 数据
4. `Range` 遍历数据
5. `LoadOrStore` 如果存在 key 数据则返回，反之则设置
6. `LoadAndDelete` 如果存在 key 数据则删除

```go
// 计算长度
demo := sync.Map{}
	
	for j := 0; j < 1000; j++ {
		demo.Store(j, j)
	}

	lens := 0
	demo.Range(func(key, value interface{}) bool {
		lens++
		return true
	})
```

### ### sync.WaitGroup

```go
func main() {
	var wg sync.WaitGroup

	wg.Add(3)

	go handlerTask1(&wg)
	go handlerTask2(&wg)
	go handlerTask3(&wg)

	wg.Wait()

	fmt.Println("全部任务执行完毕.")
}

func handlerTask1(wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Println("执行任务 1")
}

func handlerTask2(wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Println("执行任务 2")
}

func handlerTask3(wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Println("执行任务 3")
}
```

```go
// 正确
go handlerTask1(&wg)

// 错误
go handlerTask1(wg)
```

执行子任务时，使用的 `sync.WaitGroup` 一定要是 `wg` 的引用类型！

注意不要将 `wg.Add()` 放在 `go handlerTask1(&wg)` 中！

```go
// 错误
var wg sync.WaitGroup

go handlerTask1(&wg)

wg.Wait()

...

func handlerTask1(wg *sync.WaitGroup) {
	wg.Add(1)
	defer wg.Done()
	fmt.Println("执行任务 1")
}
```

### dep Golang 官方依赖管理工具

在项目下使用`dep init` 会生成如下三个文件:

- `vendor`
- `Gopkg.toml`
- `Gopkg.lock`

依赖包都会下载到 `vendor` 目录。

需要的依赖配置写在 `Gopkg.toml` 文件。

`Gopkg.lock` 暂时可以不用管。

在 `Gopkg.toml` 文件中增加依赖：

```go
[[constraint]]
name = "[github.com/gin-gonic/gin](<http://github.com/gin-gonic/gin>)"
version = "1.4.0"
```

## **Go**

### **Channel**

初始化 ：

```
make(chan 元素类型, [缓冲大小])
```

```
ch4 := make(chan int)
ch5 := make(chan bool, 1)  // 声明一个缓冲区大小为1的通道
```

### **发送**

将一个值发送到通道中。

```
ch <- 10 // 把10发送到ch中
```

### **接收**

从一个通道中接收值。

```
x := <- ch // 从ch中接收值并赋值给变量x
<-ch       // 从ch中接收值，忽略结果
```

### **关闭**

### **我们通过调用内置的`close`函数来关闭通道**

```
close(ch)
```

**注意：**一个通道值是可以被垃圾回收掉的。通道通常由`发送方`执行关闭操作，并且只有在`接收方明确等待通道关闭的信号时`才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。

关闭后的通道有以下特点：

1. 对一个关闭的通道再发送值就会导致 panic。
2. 对一个关闭的通道进行接收会一直获取值直到通道为空。
3. 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。
4. 关闭一个已经关闭的通道会导致 panic。

### **多返回值模式**

当向通道中发送完数据时，我们可以通过`close`函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发`panic`，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢？

对一个通道执行接收操作时支持使用如下多返回值模式。

```
value, ok := <- ch
```

其中：

- value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。
- ok：通道ch关闭时返回 false，否则返回 true。

下面代码片段中的`f2`函数会循环从通道`ch`中接收所有值，直到通道被关闭后退出。

```
func f2(ch chan int) {
  for {
    v, ok := <-ch
    if !ok {
      fmt.Println("通道已关闭")
      break
    }
    fmt.Printf("v:%#v ok:%#v\\n", v, ok)
  }
}

func main() {
  ch := make(chan int, 2)
  ch <- 1
  ch <- 2
  close(ch)
  f2(ch)
}
```

### **for range接收值**

通常我们会选择使用`for range`循环从通道中接收值，当通道被关闭后，会在通道内的所有值被接收完毕后会自动退出循环。上面那个示例我们使用`for range`改写后会很简洁。

```
func f3(ch chan int) {
  for v := range ch {
    fmt.Println(v)
  }
}
```

**注意：**目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过`len(ch)`操作来判断通道是否被关闭。

### **strconv**

读取文件按行读取

```
file, err := os.OpenFile("/Users/zhoukai/Desktop/and.txt", os.O_RDONLY, 0666)
	if err != nil {

		if err == io.EOF {
			close(ch)
			fmt.Printf("文件读取完毕..")
			return
		}

		fmt.Printf("打开文件错误了..")
		return
	}

	// 读取文件内容
	reader := bufio.NewReader(file)
	for {
		line, err := reader.ReadString('\\n')
		if err == io.EOF {
			if len(line) != 0 {
				fmt.Println(line)
			}
			fmt.Println("文件读完了")
			break
		}
		if err != nil {
			fmt.Println("read file failed, err:", err)
			return
		}
		ch <- line
		fmt.Print(line)
	}
```

### **确定的数据结构,应该用 struc 替换 map**

```
// 错误的做法
func BenchmarkStructOperation1(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var demo = map[string]interface{}{}
		demo["Name"] = "Tom"
		demo["Age"] = 30
	}
}
//正确的做法
func BenchmarkStructOperation2(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var demo struct {
			Name string
			Age  int
		}
		demo.Name = "Tom"
		demo.Age = 30
	}
}
```

### **字符串的拼接优先使用 bytes.NewBufferString**

对于**大量**的数据 `bytes.NewBufferString` 是性能更高

```
// fmt.Sprintf方式拼接
func BenchmarkStringOperation2(b *testing.B)  {
	b.ResetTimer()
	str := ""
	for i := 0; i < b.N; i++ {
		str = fmt.Sprintf("%s%s", str, "golang")
	}
}

// 输出
goos: darwin
goarch: amd64
pkg: demo/stringoperation
cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz
BenchmarkStringOperation2
BenchmarkStringOperation2-12    	  280140	    214098 ns/op
PASS

Process finished with the exit code 0

// + 方式拼接
func BenchmarkStringOperation1(b *testing.B)  {
	b.ResetTimer()
	str := ""
	for i := 0; i < b.N; i++ {
		str += "golang"
	}
}

// 输出
goos: darwin
goarch: amd64
pkg: demo/stringoperation
cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz
BenchmarkStringOperation1
BenchmarkStringOperation1-12    	  353318	    114135 ns/op
PASS

Process finished with the exit code 0

// bytes.NewBufferString ,最优的办法去解决
func BenchmarkStringOperation3(b *testing.B)  {
	b.ResetTimer()
	strBuf := bytes.NewBufferString("")
	for i := 0; i < b.N; i++ {
		strBuf.WriteString("golang")
	}
}

// 输出
goos: darwin
goarch: amd64
pkg: demo/stringoperation
cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz
BenchmarkStringOperation3
BenchmarkStringOperation3-12    	161292136	         8.582 ns/op
PASS

Process finished with the exit code 0

```

### **定时器**

```
func timer() {
   // 开启一个定时器,每分钟执行一次
   ticker := time.NewTicker(time.Second)
   for {
      select {
      case <-ticker.C:
         fmt.Println("定时器执行了")
      }
   }
}
```

### **NSQ**

### **跨平台编译**

Linux 下编译 Mac 和 Windows 64位可执行程序

```
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build # 编译 linux
    CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build #编译 Windows exe
```

### **创建文件**

```
fName := "courses.json"
file, err := os.Create(fName)
if err != nil {
   log.Fatalf("Cannot create file %q: %s\\n", fName, err)
   return
}
defer file.Close()
```

### **分布式消息**

`nats`

### **recover必须在defer函数中运行**

```
func main() {
    defer func() {
        recover()
    }()
    panic(1)
}
```

### **禁止 main 函数退出的方法**

```
func main() {
    defer func() { for {} }()
}

func main() {
    defer func() { select {} }()
}

func main() {
    defer func() { <-make(chan bool) }()
}
```

### **日志**

[logrus](https://github.com/sirupsen/logrus) 日志库的简单使用

```
import (
	"fmt"
	log "github.com/sirupsen/logrus"
	"os"
	"path"
	"time"
)

// 对外声明log使用
var Logger = log.New()

func init() {
	Logger.SetFormatter(&log.JSONFormatter{
		TimestampFormat: "2006-01-02 15:04:05",
	})
	Logger.SetReportCaller(true)
	Logger.SetLevel(log.DebugLevel)
	src, _ := setOutputFile()
	//设置输出
	Logger.SetOutput(src)
}

func setOutputFile() (*os.File, error) {
	now := time.Now()
	logFilePath := ""
	if dir, err := os.Getwd(); err == nil {
		logFilePath = dir + "/logs/"
	}
	_, err := os.Stat(logFilePath)
	if os.IsNotExist(err) {
		if err := os.MkdirAll(logFilePath, 0777); err != nil {
			fmt.Println(err.Error())
			return nil, err
		}
	}
	logFileName := now.Format("2006-01-02") + ".log"
	//日志文件
	fileName := path.Join(logFilePath, logFileName)
	if _, err := os.Stat(fileName); err != nil {
		if _, err := os.Create(fileName); err != nil {
			fmt.Println(err.Error())
			return nil, err
		}
	}
	//写入文件
	src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, os.ModeAppend)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return src, nil
}

```

### **XORM**

[文档地址](http://xorm.topgoer.com/)

连接的[MySQL](notion://www.notion.so/%5Bgithub.com/go-sql-driver/mysql%5D\(https://github.com/go-sql-driver/mysql\)) 对应的安装`go get -u github.com/go-sql-driver/mysql`

### **XORM Install**

`go get xorm.io/xorm`安装xorm

### **Go Mod**

`go mod init projectName` 将会生成一个mod文件

### IP池

[smartdaili](https://smartdaili.cn/)

[goquery](https://www.notion.so/goquery-409499ca8e7e4518aa59f5eab7d73bac?pvs=21)

### Robot

[地址](https://github.com/go-vgo/robotgo/tree/master)

[中文文档](https://github.com/go-vgo/robotgo/blob/master/docs/doc_zh.md)

集成：`go get github.com/go-vgo/robotgo`

[Go库](https://www.notion.so/Go-0222efeb182948518538146b5a07ecf3?pvs=21)

[杂记](https://www.notion.so/79ce7174a34d4235889f7bb0762a058e?pvs=21)