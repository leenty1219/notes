
1. 通过 REPL 将脚本注入 USB 设备上的进程
    
    可以通过以下命令在通过 USB 连接的 iOS 设备上注入 Frida 检测脚本。此处的**-n**开关（默认选项）指定要附加到的进程名称（执行此命令之前必须运行关联的应用程序），**-U**开关指定要定位到 USB 设备（因此，此选项用于所有 与**iOS**相关的命令）。
    
    `$ frida -U -n Twitter -l demo1.js`
    
2. 列出 USB 设备上所有正在运行的进程名称和 PID
    
    以下命令以表格形式列出 iOS 设备中所有正在运行的进程，其中包含 PID 和名称列。请记住，**-U**指定正在查询 USB 设备。
    
    `$ frida-ps -U`
    
3. 列出 USB 设备上安装的所有应用程序
    
    以下命令以表格形式列出**USB 设备上安装的所有应用程序，其中包含 PID、名称和标识符列。**
    
    `$ frida-ps -Uai`
    
4. 列出 USB 设备上所有正在运行的应用程序
    
    以下命令以表格形式列出**USB 设备上所有正在运行的应用程序，其中包含 PID、名称和标识符列。**
    
    `$ frida-ps -Ua`
    
5. 列出所有连接的设备
    
    以下命令列出所有可用的 Frida 设备，包括通过 USB 连接的设备。Frida 可以检测这些设备上的进程。
    
    `$ frida-ls-devices`
    
6. 跟踪本机 API
    
    以下命令可用于跟踪特定进程中的本机 API。可以使用通配符指定函数名称 _（如下所示）_，这在探索或发现进程内的用户定义函数时特别有用。
    
    `$ frida-trace -U Twitter -i "*URL*"`
    
7. 跟踪 Objective-C API
    
    以下命令可用于跟踪特定进程中的 Objective-C API。请注意开关的区别，在本例中是**-m**而不是**-i**。Objective-C API 名称、类名称以及方法类型（类方法或实例方法）都可以使用通配符指定*（如下所示）*。这在探索或发现进程内的用户定义方法时特别有用。
    
    `$ frida-trace -U Twitter -m "-[NSURL* *HTTP*]"`
    
8. 回溯 Objective-C 方法调用
    
    以下命令可用于生成特定进程中 Objective-C 方法调用的回溯。
    
    > 提示：将以下代码添加到所需 API 自动生成的 JS 中的onEnter事件处理程序中
    
    `log('\\tBacktrace:\\n\\t' + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress) .join('\\n\\t'));`
    
9. 将数据写入文件
    
    如果您想将一些数据写入文件，您应该`send()`从注入的脚本中获取数据并在基于 Frida 的应用程序中接收它，然后将其写入文件。
    
    > 提示：数据send()应该是 JSON 可序列化的。
    

## OC数据处理

1. 将 NSData 转换为字符串
    
    ```jsx
    const data = new ObjC.Object(args[2]);
    data.bytes().readUtf8String(data.length());
    ```
    
    > 提示：如果字符串数据以空字符结尾，则不需要第二个参数（字节数）。
    
2. 将 NSData 转换为二进制数据
    
    ```jsx
    const data = new ObjC.Object(args[2]);
    data.bytes().readByteArray(data.length());
    ```
    
3. 迭代 NSArray
    

```jsx
const array = new ObjC.Object(args[2]);
/*
 * Be sure to use valueOf() as NSUInteger is a Number in
 * 32-bit processes, and UInt64 in 64-bit processes. This
 * coerces it into a Number in the latter case.
 */
const count = array.count().valueOf();
for (let i = 0; i !== count; i++) {
  const element = array.objectAtIndex_(i);
}
```

1. 迭代 NSDictionary
    
    ```jsx
    const dict = new ObjC.Object(args[2]);
    const enumerator = dict.keyEnumerator();
    let key;
    while ((key = enumerator.nextObject()) !== null) {
      const value = dict.objectForKey_(key);
    }
    ```
    
2. 取消存档 NSKeyedArchiver
    
    ```jsx
    const parsedValue = ObjC.classes.NSKeyedUnarchiver.unarchiveObjectWithData_(value);
    ```
    
3. 读取结构体
    
    如果 args[0] 是指向结构的指针，并且假设您想要读取偏移量 4 处的 uint32，则可以按如下所示执行操作：
    
    ```jsx
    args[0].add(4).readU32();
    ```
    

## Objective-C 示例

### 在 iOS 7 上显示警告框

```jsx
const UIAlertView = ObjC.classes.UIAlertView; /* iOS 7 */
const view = UIAlertView.alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles_(
    'Frida',
    'Hello from Frida',
    NULL,
    'OK',
    NULL);
view.show();
view.release();
```

### 在 iOS >= 8 上显示警告框

[这是以下代码](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAlertController_class/)的实现 。

```jsx
// Defining a Block that will be passed as handler parameter to +[UIAlertAction actionWithTitle:style:handler:]
const handler = new ObjC.Block({
  retType: 'void',
  argTypes: ['object'],
  implementation() {
  }
});// Import ObjC classes
const UIAlertController = ObjC.classes.UIAlertController;
const UIAlertAction = ObjC.classes.UIAlertAction;
const UIApplication = ObjC.classes.UIApplication;// Using Grand Central Dispatch to pass messages (invoke methods) in application's main thread
ObjC.schedule(ObjC.mainQueue, () => {
  // Using integer numerals for preferredStyle which is of type enum UIAlertControllerStyle
  const alert = UIAlertController.alertControllerWithTitle_message_preferredStyle_('Frida', 'Hello from Frida', 1);
  // Again using integer numeral for style parameter that is enum
  const defaultAction = UIAlertAction.actionWithTitle_style_handler_('OK', 0, handler);
  alert.addAction_(defaultAction);
  // Instead of using `ObjC.choose()` and looking for UIViewController instances
  // on the heap, we have direct access through UIApplication:
  UIApplication.sharedApplication().keyWindow().rootViewController().presentViewController_animated_completion_(alert, true, NULL);
});
```

### 打印 NSURL 参数

下面的代码展示了如何拦截对 [UIApplication openURL:] 的调用并显示传递的 NSURL。

```jsx
// Get a reference to the openURL selector
const openURL = ObjC.classes.UIApplication['- openURL:'];// Intercept the method
Interceptor.attach(openURL.implementation, {
  onEnter(args) {
    // As this is an Objective-C method, the arguments are as follows:
    // 0. 'self'
    // 1. The selector (openURL:)
    // 2. The first argument to the openURL method
    const myNSURL = new ObjC.Object(args[2]);
    // Convert it to a JS string
    const myJSURL = myNSURL.absoluteString().toString();
    // Log it
    console.log('Launching URL: ' + myJSURL);
  }
});
```