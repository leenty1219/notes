# 命令

## frida-ps

- `frida-ps -U` 列出当前USB连接设备所有运行的程序
- `frida-ps -Ua` 列出当前USB活跃的程序
- `frida-ps -Uai` 列出所有安装的程序
- `frida-ps -D` 连接某设备，后面跟设备ID

## frida-trace

参数意义：[https://frida.re/docs/frida-trace/](https://frida.re/docs/frida-trace/)

# JS Api

[https://frida.re/docs/javascript-api/](https://frida.re/docs/javascript-api/)

## Process

### 属性

- `id` 包含数字形式的 PID 的属性
- `arch` 包含字符串`ia32`、`x64`或`arm` 的属性`arm64`
- `platform` 包含字符串`windows`、`darwin`、 `linux`
- `pageSize` 虚拟内存页面的大小
- `pointerSize` 以数字形式保存指针的大小（以字节为单位）
- `codeSigningPolicy` 属性包含字符串`optional`或 `required`
- `mainModule` 主要可执行文件的属性
- `getCurrentDir` 当前工作目录的文件系统路径的字符串
- `getHomeDir` 当前用户主目录的文件系统路径的字符串
- `getTmpDir` 指定用于临时文件的目录的文件系
- `isDebuggerAttached` 当前是否连接了调试器
- `getCurrentThreadId` 该线程的操作系统特定 ID 作为数字
- `enumerateThreads` 枚举当前线程，是一个Thread的数组
- `attachThreadObserver(callbacks)` 开始观察线程
- `runOnThread` 指定的线程上运行
- `findModuleByAddress` 返回_地址_或_名称_与指定值匹配的[**模块**](https://frida.re/docs/javascript-api/#module)。如果找不到这样的模块，则 _find_前缀的函数将返回_null_
- `getModuleByAddress` 而_get_前缀的函数将抛出异常
- `findModuleByName`
- `getModuleByName`
- `enumerateModules` 枚举当前加载的模块，返回一个[**Module**](https://frida.re/docs/javascript-api/#module)对象数组。
- `attachModuleObserver` 开始观察模块
- `findRangeByAddress`
- `getRangeByAddress`
- `enumerateMallocRanges` 系统堆已知的单独内存分配
- `setExceptionHandler` 进程范围的异常处理程序回调

## ApiResolver

初始化 `const resolver = new ApiResolver('type');` 其中`type`值

- `module` 解析模块的导出、导入和节。始终可用
- `swift` 解析Swift函数
- `objc` 解析 Objective-C 方法

其中 `Swift.available` 和 `ObjC.available`将在运行时检查

### enumerateMatches

执行特定于解析器的`query`字符串

```jsx
const resolver = new ApiResolver('objc');
const matches = resolver.enumerateMatches('-[NSURL* *HTTP*]');
const first = matches[0];
/*
 * Where `first` is an object similar to:
 *
 * {
 *   name: '-[NSURLRequest valueForHTTPHeaderField:]',
 *   address: ptr('0x7fff94183e22')
 * }
 */
```

## Interceptor

### attach

拦截对函数的调用`target`。这指定了您想要拦截调用的函数的地址

```jsx
Interceptor.attach(Module.getExportByName('libc.so', 'read'), {
  onEnter(args) {
    this.fileDescriptor = args[0].toInt32();
  },
  onLeave(retval) {
    if (retval.toInt32() > 0) {
      /* do something with this.fileDescriptor */
    }
  }
});
```

### replace

将 处的函数替换 `target`为 处的实现`replacement`。通常，当你想完全或部分替换现有函数的实现时使用这种方法。

```jsx
const openPtr = Module.getExportByName('libc.so', 'open');
const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);
Interceptor.replace(openPtr, new NativeCallback((pathPtr, flags) => {
  const path = pathPtr.readUtf8String();
  log('Opening "' + path + '"');
  const fd = open(pathPtr, flags);
  log('Got fd: ' + fd);
  return fd;
}, 'int', ['pointer', 'int']));
```

## Stalker

```jsx
const mainThread = Process.enumerateThreads()[0];

Stalker.follow(mainThread.id, {
  events: {
    call: true, // CALL instructions: yes please

    // Other events:
    ret: false, // RET instructions
    exec: false, // all instructions: not recommended as it's
                 //                   a lot of data
    block: false, // block executed: coarse execution trace
    compile: false // block compiled: useful for coverage
  },

  //
  // Only specify one of the two following callbacks.
  // (See note below.)
  //

  //
  // onReceive: Called with `events` containing a binary blob
  //            comprised of one or more GumEvent structs.
  //            See `gumevent.h` for details about the
  //            format. Use `Stalker.parse()` to examine the
  //            data.
  //
  //onReceive(events) {
  //},
  //

  //
  // onCallSummary: Called with `summary` being a key-value
  //                mapping of call target to number of
  //                calls, in the current time window. You
  //                would typically implement this instead of
  //                `onReceive()` for efficiency, i.e. when
  //                you only want to know which targets were
  //                called and how many times, but don't care
  //                about the order that the calls happened
  //                in.
  //
  onCallSummary(summary) {
  },

  //
  // Advanced users: This is how you can plug in your own
  //                 StalkerTransformer, where the provided
  //                 function is called synchronously
  //                 whenever Stalker wants to recompile
  //                 a basic block of the code that's about
  //                 to be executed by the stalked thread.
  //
  //transform(iterator) {
  //  let instruction = iterator.next();
  //
  //  const startAddress = instruction.address;
  //  const isAppCode = startAddress.compare(appStart) >= 0 &&
  //      startAddress.compare(appEnd) === -1;
  //
  //  /*
  //   * Need to be careful on ARM/ARM64 as we may disturb instruction sequences
  //   * that deal with exclusive stores.
  //   */
  //  const canEmitNoisyCode = iterator.memoryAccess === 'open';
  //
  //  do {
  //    if (isAppCode && canEmitNoisyCode && instruction.mnemonic === 'ret') {
  //      iterator.putCmpRegI32('eax', 60);
  //      iterator.putJccShortLabel('jb', 'nope', 'no-hint');
  //
  //      iterator.putCmpRegI32('eax', 90);
  //      iterator.putJccShortLabel('ja', 'nope', 'no-hint');
  //
  //      iterator.putCallout(onMatch);
  //
  //      iterator.putLabel('nope');
  //
  //      /* You may also use putChainingReturn() to insert an early return. */
  //    }
  //
  //    iterator.keep();
  //  } while ((instruction = iterator.next()) !== null);
  //},
  //
  // The default implementation is just:
  //
  //   while (iterator.next() !== null)
  //     iterator.keep();
  //
  // The example above shows how you can insert your own code
  // just before every `ret` instruction across any code
  // executed by the stalked thread inside the app's own
  // memory range. It inserts code that checks if the `eax`
  // register contains a value between 60 and 90, and inserts
  // a synchronous callout back into JavaScript whenever that
  // is the case. The callback receives a single argument
  // that gives it access to the CPU registers, and it is
  // also able to modify them.
  //
  // function onMatch (context) {
  //   console.log('Match! pc=' + context.pc +
  //       ' rax=' + context.rax.toInt32());
  // }
  //
  // Note that not calling keep() will result in the
  // instruction getting dropped, which makes it possible
  // for your transform to fully replace certain instructions
  // when this is desirable.
  //

  //
  // Want better performance? Write the callbacks in C:
  //
  // /*
  //  * const cm = new CModule(\\`
  //  *
  //  * #include <gum/gumstalker.h>
  //  *
  //  * static void on_ret (GumCpuContext * cpu_context,
  //  *     gpointer user_data);
  //  *
  //  * void
  //  * transform (GumStalkerIterator * iterator,
  //  *            GumStalkerOutput * output,
  //  *            gpointer user_data)
  //  * {
  //  *   cs_insn * insn;
  //  *
  //  *   while (gum_stalker_iterator_next (iterator, &insn))
  //  *   {
  //  *     if (insn->id == X86_INS_RET)
  //  *     {
  //  *       gum_x86_writer_put_nop (output->writer.x86);
  //  *       gum_stalker_iterator_put_callout (iterator,
  //  *           on_ret, NULL, NULL);
  //  *     }
  //  *
  //  *     gum_stalker_iterator_keep (iterator);
  //  *   }
  //  * }
  //  *
  //  * static void
  //  * on_ret (GumCpuContext * cpu_context,
  //  *         gpointer user_data)
  //  * {
  //  *   printf ("on_ret!\\n");
  //  * }
  //  *
  //  * void
  //  * process (const GumEvent * event,
  //  *          GumCpuContext * cpu_context,
  //  *          gpointer user_data)
  //  * {
  //  *   switch (event->type)
  //  *   {
  //  *     case GUM_CALL:
  //  *       break;
  //  *     case GUM_RET:
  //  *       break;
  //  *     case GUM_EXEC:
  //  *       break;
  //  *     case GUM_BLOCK:
  //  *       break;
  //  *     case GUM_COMPILE:
  //  *       break;
  //  *     default:
  //  *       break;
  //  *   }
  //  * }
  //  * `);
  //  */
  //
  //transform: cm.transform,
  //onEvent: cm.process,
  //data: ptr(1337) /* user_data */
  //
  // You may also use a hybrid approach and only write
  // some of the callouts in C.
  //
});
Performance considerations
The callbacks provided have a significant impact on performance. If you only need periodic call summaries but do not care about the raw events, or the other way around, make sure you omit the callback that you don't need; i.e. avoid putting your logic in onCallSummary and leaving onReceive in there as an empty callback.

Also note that Stalker may be used in conjunction with CModule, which means the callbacks may be implemented in C.

Stalker.unfollow([threadId]): stop stalking threadId (or the current thread if omitted).

Stalker.parse(events[, options]): parse GumEvent binary blob, optionally with options for customizing the output.

For example:

  onReceive(events) {
    console.log(Stalker.parse(events, {
      annotate: true, // to display the type of event
      stringify: true
        // to format pointer values as strings instead of `NativePointer`
        // values, i.e. less overhead if you're just going to `send()` the
        // thing not actually parse the data agent-side
    }));
  },
```

## Objc

- available
- api 用于直接访问大部分 Objective-C 运行时 API
- classes
- protocols
- mainQueue
- schedule

```jsx
const { NSSound } = ObjC.classes; /* macOS */
ObjC.schedule(ObjC.mainQueue, () => {
    const sound = NSSound.alloc().initWithContentsOfFile_byReference_("/Users/oleavr/.Trash/test.mp3", true);
    sound.play();
});
```

`ObjC.classes` ：将类名映射到 [`ObjC.Object`](https://frida.re/docs/javascript-api/#objc-object) 对象 当前已注册的每个类的 JavaScript 绑定。您可以交互 使用点符号并用下划线替换冒号来表示对象，即： `[NSString stringWithString:@"Hello World"]` 变成 `const { NSString } = ObjC.classes; NSString.stringWithString_("Hello World");`