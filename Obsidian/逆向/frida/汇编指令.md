# 1. 寄存器

```jsx
; 这是一个汇编的注释，以 ; 开头
```

## 1.1 通用寄存器

64bit的是`x0~x28`

32bit的是`w0~x28`，在64 bit中低32bit

## 1.2 程序计数器

pc

# 2.指令

汇编指令不区分大小写，`mov`和MOV是一样的

## 2.1 mov

用法： `mov 目的寄存器 源操作数`

```jsx
mov x0, #0x8 // 立即数应该用#标识，用十六进制标识
mov x1, x0
```

## 2.2 add & sub

用法：`add x0 , x1 , x2`

用法：`sub x0 , x1 , x2`

```jsx
mov x0 , #0x1
mov x1 , #0x2
add x3 , x1 , x0 //将 x1 加 x0 的结果赋值给 x3 
; 减法
mov x0 , #0x5
mov x1 , #0x2
add x3 , x0 , x1 //将 x0 减 x1 的结果赋值给 x3 
```

## 2.3 cmp &b

用法：`cmp x0, x1` 拿`x0`的值减去`x1`，并把结果放到 `cpsr` 中（current program status register）

```jsx
mov x0 , #0x1
mov x1 , #0x2
cmp x0, x1 
```

其中`cpsr`是32位，结构如下：

![CPSR01.png](attachment:aa5671c3-42c3-4e93-8a96-72743e99799d:CPSR01.png)

![CPSR02.png](attachment:ac794cc9-64f4-40eb-abd9-b55f28670da8:CPSR02.png)

`b` 指令 `跳转`

用法：`b 0x10008e840` 跳转到某个地址

```jsx
b mycode // 跳转到mycode，类似C里面的 ‘goto’
mov x0, #0x5
mycode: // 打标记
mov x1, #0x6
```

- 带条件跳转

`b {} 目标地址`

```jsx
mov x0 , #0x1
mov x1 , #0x2
cmp x0, x1
beq othercode // 如果cpsr里面的数据相等（eq），跳转到 mycode
mycode: // 打标记
mov x1, #0x6
ret
othercode: // 打标记
mov x2, #0x6
```

![指令的条件域.png](attachment:765ff0f4-a725-47e0-95e5-e20577b928fe:%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%9F%9F.png)

- `bl` 带返回的跳转指令，类似函数调用，调用完别的函数继续执行当前的流程

## 2.4 内存操作

### 2.4.1 ldr ldur ldp取数据

从内存中读取数据，基本都是`l`开头的（load）

- `ldr、ldur` : 从内存读取数据到寄存器
- `ldp` : 从内存读取数据放到一对寄存器

```jsx
ldr x0, [x1] // 从X1寄存器存储的地址取值，取值范围是X0寄存器的大小。此时x1里面必须是内存地址
// ldur 和 ldr 功能一样。
// 区别：牵扯到硬件的区别，如果后面的立即数是负数用的是ldur，正数用的是ldr
ldr x1 , [x2 , #0x4]! // 从X2地址中取值加4之后赋值给x1,'!'表明X2的值等于x2 + 4（也修改x2的值）。 
 
ldp x29 ,x39,[sp, #0x50] // p是pari的简称，用x29和x39两个寄存器来存储 sp寄存器中的内存地址值 + 0x50
```

### 2.4.2 str stur stp存数据

`s`开头的基本都是存数据，存储指令**不能赋值立即数**

- `str 、stur`
- `stp`

```jsx
str x0, [sp #0x24] // 和ldr类似，取x0（值）的值加上0x24 写入到sp + 0x24的内存地址中
```

## 2.5 零寄存器 wzr xzr

- `wzr` : 32位（4字节） 里面存储的东西是0，`zr（zero）`
- `xzr` : 64位 （8字节）里面存储的东西是0

## 2.6 程序计数器寄存器 pc

记录当前Cpu当前指令的是哪一条指令

存储着当前Cpu正在执行的指令的地址

## 2.7 链接寄存器 lr

`lr` 和 `x30`是同一个寄存器，存储着函数 返回后继续执行的地址

eg. 当汇编遇到`bl` 指令跳转时，`lr`寄存器记录下一条指令后去执行跳转操作（比如跳转到函数），在函数执行完毕后（遇到`ret`指令），从`lr`寄存器的地址从新执行

```jsx
int a;
int b; // 这里即将要去执行 func 函数，lr记录的是 int c这行代码的指令地址，从func ret后，继续执行
func()
int c;
```

## 2.8 堆栈寄存器 sp 、fp

`fp`寄存器也是`x29`寄存器

### 2.8.1 叶子函数：内部没有别的函数调用

### 2.8.2 非叶子函数：内部还有别的函数调用

## 2.3 jmp

## 2.3 ret 返回指令

等效于函数的`return`

```jsx
.text // 指明汇编所处的内存区域（代码段）

.global _test , _add , _sub
_test: // 生命一个test函数,底层默认是带下划线
mov x0,8 
ret  // 函数结束

_add: //添加的add函数, 如果函数有参数，依次放在x0,x1,x2...x7,如果有更多的参数会放在堆栈
add x0, x0,x1 //x0通常放函数的返回值
ret // 函数结束

_sub: //添加sub函数
add x0, x0,x1  
ret // 函数结束
```

# 3.堆栈